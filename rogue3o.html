<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒ­ãƒ¼ã‚°ã£ã½ã„ä½•ã‹ï¼ˆãƒŸãƒ‹ãƒãƒƒãƒ—æ”¹ä¿®ç‰ˆï¼‰</title>
  <style>
    /* å…¨ä½“ãƒªã‚»ãƒƒãƒˆ */
    * { user-select: none; margin: 0; padding: 0; box-sizing: border-box; }
    /* é›£æ˜“åº¦é¸æŠç”¨ãƒãƒƒãƒ— */
    #game { 
      font-size: 24px; 
      line-height: 1.2; 
      white-space: pre; 
      position: relative; 
      margin-right: 20px; 
    }
    #homeScreen { display: none; } /* æ—§ãƒ›ãƒ¼ãƒ ç”»é¢ã¯å‰Šé™¤ */

    /* èƒŒæ™¯ã¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    body { 
      font-family: monospace; 
      background-color: #000; 
      color: #eee; 
      display: flex; 
      flex-flow: column;
      height: 100vh; 
      align-items: center; 
      justify-content: center; 
    }
    /* ã‚¿ã‚¤ãƒˆãƒ«ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    #title-container {
      display: flex;
      flex-flow: column;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-family: monospace;
      padding: 20px;
      margin-bottom: 20px;
      background: linear-gradient(90deg, #f00, #0f0, #00f);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientAnimation 3s ease infinite;
    }
    @keyframes gradientAnimation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    .container { display: flex; }
    /* ãƒ¡ã‚¤ãƒ³ç”»é¢ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸­å¿ƒ15Ã—15è¡¨ç¤ºï¼‰ */
    .game-container { 
      font-size: 24px; 
      line-height: 1.2; 
      white-space: pre; 
      position: relative; 
      margin-right: 20px; 
    }
    .game-container span { 
      background-color: #333;
      display: inline-block; 
      width: 2.2ch; 
      text-align: center; 
      transition: all 0.1s; 
    }
    /* UIã‚µã‚¤ãƒ‰ãƒãƒ¼ */
    .ui-container { 
      width: 360px; 
      background: #222; 
      padding: 10px; 
      border: 2px solid #555; 
      border-radius: 4px; 
    }
    .wall { background-color: #333; display: inline-block; height: 20px; }
    .hit { background-color: red !important; color: white; }
    .shake { transform: translateY(-2px); }
    /* ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ */
    .damage, .damage-me, .heal, .explosion, .food {
      position: absolute; 
      font-weight: bold; 
      font-size: 18px; 
      border-radius: 4px;
      pointer-events: none; 
      transform: translate(-50%, -100%);
      animation: floatUp 1.0s ease-out forwards;
    }
    .damage-me { color: white; background-color: red; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .damage { color: white; background-color: orange; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .heal { color: white; background-color: green; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .food { color: white; background-color: green; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .explosion { color: orange; font-size: 22px; animation: explodeUp 0.4s ease-out forwards; }
    @keyframes floatUp { 
      0% { opacity: 1; transform: translate(-50%, -100%) scale(1); } 
      100% { opacity: 0; transform: translate(-50%, -160%) scale(1.3); } 
    }
    @keyframes explodeUp { 
      0% { opacity: 1; transform: translate(-50%, -100%) scale(0.8); } 
      100% { opacity: 0; transform: translate(-50%, -180%) scale(1.6); } 
    }
    /* é­”æ³•ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ */
    .magic-particle {
      position: absolute;
      font-size: 20px;
      pointer-events: none;
      animation: magicFloat 0.8s ease-out forwards;
      opacity: 0.8;
    }
    @keyframes magicFloat {
      0%   { transform: translateY(0px) scale(1); opacity: 0.8; }
      100% { transform: translateY(-20px) scale(1.2); opacity: 0; }
    }
    /* é›£æ˜“åº¦ */
    #difficulty-container {
      border-bottom: 1px solid white;
    }
    /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
    .bar-container { 
      width: 200px; 
      height: 16px; 
      background-color: #555; 
      border: 1px solid #999; 
      border-radius: 20px; 
      margin-bottom: 6px; 
      position: relative; 
    }
    .bar { 
      height: 100%; 
      border-radius: 20px; 
      text-align: center; 
      color: white; 
      font-size: 12px; 
      line-height: 16px; 
    }
    .bar.hp { background-color: green; }
    .bar.hunger { background-color: skyblue; }
    p { 
      font-size: 14px; 
      line-height: 1.4; 
      margin-bottom: 8px; 
    }
    /* ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
    .inventory-modal {
      font-size: .7em;
      position: absolute;
      top: 20%;
      left: 20%;
      width: 80%;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px;
      border: 2px solid white;
      z-index: 1000;
    }
    .inventory-modal h3 { margin-top: 0; }
    .inventory-modal ul { list-style: none; padding: 0; }
    .inventory-modal li { padding: 4px 0; }
    .inventory-modal li.selected { background: #444; }
    /* ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨ */
    .minimap-container {
      margin-top: 20px;
      background: #111;
      padding: 4px;
      display: grid;
      grid-auto-rows: 4px;
      gap: 0;
    }
    .minimap-cell {
      width: 4px;
      height: 4px;
    }
    /* çµæœè¡¨ç¤ºç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« */
    .results-modal {
      font-size: 1em;
      position: absolute;
      top: 20%;
      left: 20%;
      width: 60%;
      background: rgba(0, 0, 0, 0.95);
      color: #eee;
      padding: 20px;
      border: 2px solid white;
      z-index: 2000;
    }
    .results-modal h3 { margin-top: 0; }
    .results-modal table {
      width: 100%;
      border-collapse: collapse;
    }
    .results-modal table, .results-modal th, .results-modal td {
      border: 1px solid #eee;
    }
    .results-modal th, .results-modal td {
      padding: 5px;
      text-align: center;
    }
    .results-modal button {
      margin-top: 10px;
      padding: 5px 10px;
    }
    /* é›£æ˜“åº¦ã«åˆã‚ã›ãŸèƒŒæ™¯å¤‰æ›´ */
    body.easy-dungeon { background-color: #444 !important; }
    body.hard-dungeon { background-color: #222 !important; }
    body.deep-dungeon { background-color: #000 !important; }
  </style>
</head>
<body>
  <!-- DifficultySelectorç”¨ã®ç”»é¢ã¯ã€Œgameã€ã‚³ãƒ³ãƒ†ãƒŠã‚’æµç”¨ -->
  <div class="container">
    <div class="game-container" id="game"></div>
    <div class="ui-container">
      <div id="difficulty-container">é›£æ˜“åº¦ï¼š <span id="difficulty"></span></div>
      â¤ï¸ ä½“åŠ›: <div class="bar-container"><div id="hp-bar" class="bar hp"></div></div>
      ğŸ— æº€è…¹åº¦: <div class="bar-container"><div id="hunger-bar" class="bar hunger"></div></div>
      <p style="display:none;">â¤ï¸ ä½“åŠ›: <span id="hp">*</span> / <span id="maxhp">*</span>ã€€ğŸ— æº€è…¹åº¦: <span id="hunger">*</span> / <span id="maxhunger">*</span></p>
      <p>ğŸ”ª æ”»æ’ƒåŠ›: <span id="atk">*</span>ã€€ğŸ“ Lv: <span id="lv">1</span>ã€€âœ¨ EXP: <span id="exp">0</span></p>
      <p>â›°ï¸ ãƒ•ãƒ­ã‚¢: <span id="floor">1</span>ã€€ğŸ’ ã‚¹ã‚³ã‚¢: <span id="score">0</span></p>
      <p>ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
      <p>çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ï¼æ•µã¨éš£æ¥ã—ã¦ãŸã‚‰æ”»æ’ƒï¼</p>
      <p>ï¼ã§ä¼‘æ†©ï¼ˆ<span id="restCycle"></span>ã‚¿ãƒ¼ãƒ³ã”ã¨ã«å›å¾©ï¼‰ã€€ğŸ”¼:æ¬¡ã®ãƒ•ãƒ­ã‚¢ã¸</p>
      <p>â€» Shiftï¼‹æ–¹å‘ã‚­ãƒ¼ã§æ–œã‚ç§»å‹•</p>
      <p>eã‚­ãƒ¼ã§ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªè¡¨ç¤º</p>
      <p>rã‚­ãƒ¼ã§çµæœè¡¨ç¤º</p>
      <p>ğŸŸ¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€€ğŸŸ¥æ•µã€€ğŸŸ¦ã‚¢ã‚¤ãƒ†ãƒ </p>
      <!-- ãƒŸãƒ‹ãƒãƒƒãƒ— -->
      <div id="minimap" class="minimap-container"></div>
    </div>
  </div>
  
  <script>
    // é›£æ˜“åº¦ã”ã¨ã®è¨­å®š
    const difficultySettings = {
      easy:   { name: "æ£®ãƒ¬ãƒ™ãƒ«", wallEmoji: "ğŸŒ³", maxFloor: 10, revealLv: 5 },
      normal: { name: "å±±ãƒ¬ãƒ™ãƒ«", wallEmoji: "â›°ï¸", maxFloor: 30, revealLv: 3 },
      hard:   { name: "ç«å±±ãƒ¬ãƒ™ãƒ«", wallEmoji: "ğŸŒ‹", maxFloor: 99, revealLv: 2 }
    };

    // ---------------- Configuration ----------------
    const CONFIG = {
      WIDTH: 40,
      HEIGHT: 32,
      INITIAL_HP: 8,
      REST_CYCLE: 5,
      GENERATE_ENEMY_CYCLE: 30,
      HUNGER_CYCLE: 5,
      MIN_ENEMY_MULTIPLIER: 1.1,
      MAX_ENEMY_MULTIPLIER: 1.4,
      INVENTORY_MAX: 10,
      VIEW_RADIUS: 7,  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨å›²7ãƒã‚¹
      DIFFICULTY: "easy",  // åˆæœŸå€¤ã€‚DifficultySelectorã§ä¸Šæ›¸ã
      REVEALLV: 3 // åˆæœŸå€¤ã€‚DifficultySelectorã§ä¸Šæ›¸ã
    };
    
    // MAP_TILE ã¯é¸æŠã•ã‚ŒãŸé›£æ˜“åº¦ã«å¿œã˜ã¦æ›´æ–°
    const MAP_TILE = {
      WALL: "ğŸŒ³",  // defaultã¯Normalç”¨ã€‚startDungeonGame()ã§å¤‰æ›´
      STEPS: 'ğŸ”¼'
    };

    // ---------------- Helper Functions ----------------
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // ---------------- Base Entity Class ----------------
    class BaseEntity {
      constructor(x, y, tile) {
        this.x = x;
        this.y = y;
        this.tile = tile;
      }
    }

    // ---------------- Player Class ----------------
    class Player extends BaseEntity {
      constructor(x, y, initialHP, tile='ğŸ˜Š') {
        super(x, y, tile);
        this.hp = initialHP;
        this.maxHp = initialHP;
        this.attack = 2;
        this.healAmount = 3;
        this.level = 1;
        this.exp = 0;
        this.hunger = 100;
        this.maxHunger = 100;
        this.inventory = [];
        this.weapon = null;
      }
    }

    // ---------------- Enemy Classes ----------------
    class Enemy extends BaseEntity {
      static floorRange = [1, 3];
      constructor(x, y, hp, atk=1, tile='ğŸ‘¾') {
        super(x, y, tile);
        this.hp = hp;
        this.atk = atk;
        this.action = 1;
        this.maxAction = 1;
      }
      takeDamage(damage) {
        this.hp -= damage;
      }
    }
    class EnemyLarvae extends Enemy {
      static floorRange = [1, 5];
      constructor(x, y, hp) {
        super(x, y, hp, 1, 'ğŸ›');
      }
    }
    class EnemyAnt extends Enemy {
      static floorRange = [2, 7];
      constructor(x, y, hp) {
        super(x, y, hp + 2, 2, 'ğŸœ');
      }
    }
    class EnemyCrayfish extends Enemy {
      static floorRange = [3, 9];
      constructor(x, y, hp) {
        super(x, y, hp + 3, 3, 'ğŸ¦');
      }
    }
    class EnemySlime extends Enemy {
      static floorRange = [5, 8];
      constructor(x, y, hp) {
        super(x, y, hp + 5, 1, 'ğŸŸ©');
        this.regenerationRate = 1;
      }
      takeDamage(damage) {
        super.takeDamage(damage);
        if (this.hp > 0) { this.hp += this.regenerationRate; }
      }
    }
    class EnemyBat extends Enemy {
      static floorRange = [7, 12];
      constructor(x, y, hp) {
        super(x, y, hp, 2, 'ğŸ¦‡');
        this.evasion = 0.3;
      }
    }
    class EnemyGoblin extends Enemy {
      static floorRange = [8, 13];
      constructor(x, y, hp) {
        super(x, y, hp + 8, 4, 'ğŸ‘¹');
        this.stealChance = 0.2;
      }
    }
    class EnemySkeleton extends Enemy {
      static floorRange = [10, null];
      constructor(x, y, hp) {
        super(x, y, hp + 10, 4, 'ğŸ’€');
        this.resurrectionTimer = 0;
      }
    }
    class EnemySpider extends Enemy {
      static floorRange = [10, null];
      constructor(x, y, hp) {
        super(x, y, hp + 8, 3, 'ğŸ•·ï¸');
        this.poisonDamage = 1;
      }
    }
    class EnemyWizard extends Enemy {
      static floorRange = [10, null];
      constructor(x, y, hp) {
        super(x, y, hp + 12, 5, 'ğŸ§™');
        this.magicDamage = 2;
      }
    }
    const enemyList = (floor, difficulty) => {
      const list = [];
      let enemyClasses;
      console.log("enemy list " + difficulty);
      
      switch (difficulty) {
      case "easy":
        enemyClasses = [
          EnemyLarvae, EnemyAnt, EnemyCrayfish, EnemySlime
        ];
        enemyClasses.forEach(c => {
          if (c.floorRange[0] <= floor && (c.floorRange[1] == null || floor <= c.floorRange[1])) {
            list.push(c);
          }
        });
        break;
      case "normal":
        enemyClasses = [
          EnemyAnt, EnemyCrayfish, EnemySlime,
          EnemyBat, EnemyGoblin, EnemySkeleton
        ];
        enemyClasses.forEach(c => {
          if (c.floorRange[0] <= floor && (c.floorRange[1] == null || floor <= c.floorRange[1])) {
            list.push(c);
          }
        });
        break;
      case "hard":
        enemyClasses = [
          EnemyLarvae, EnemyAnt, EnemyCrayfish, EnemySlime,
          EnemyBat, EnemyGoblin, EnemySkeleton, EnemySpider, EnemyWizard
        ];
        enemyClasses.forEach(c => {
          if (c.floorRange[0] <= floor && (c.floorRange[1] == null || floor <= c.floorRange[1])) {
            list.push(c);
          }
        });
        break;
      }
      
      return list;
    };

    // ---------------- InventoryItem Class ----------------
    class InventoryItem extends BaseEntity {
      constructor(x, y, name, tile, useFunction) {
        super(x, y, tile);
        this.name = name;
        this.use = useFunction;
      }
    }

    // ---------------- MagicSpell ã‚¯ãƒ©ã‚¹ ----------------
    class MagicSpell extends InventoryItem {
      constructor(x, y, name, tile, emoji, options) {
        super(x, y, name, tile, (game) => {
          let affected = false;
          EffectsManager.showMagicEffect(game.gameContainer, game.player, game.player.x, game.player.y, this.area, this.emoji || "âœ¨");
          for (let i = game.enemies.length - 1; i >= 0; i--) {
            let enemy = game.enemies[i];
            if (Math.abs(enemy.x - game.player.x) <= this.area &&
                Math.abs(enemy.y - game.player.y) <= this.area) {
              enemy.hp -= this.damage;
              EffectsManager.showEffect(game.gameContainer, game.player, enemy.x, enemy.y, `-${this.damage}`, "damage");
              affected = true;
              if (enemy.hp <= 0) {
                EffectsManager.showEffect(game.gameContainer, game.player, enemy.x, enemy.y, "ğŸ’¥", "explosion");
                game.enemies.splice(i, 1);
                game.score += 50;
                game.gainExp(5);
              }
            }
          }
          if (this.fallbackHeal && !affected) {
            game.player.hp += this.fallbackHeal;
            if (game.player.hp > game.player.maxHp) game.player.hp = game.player.maxHp;
            EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, `+${this.fallbackHeal}`, "heal");
          }
        });
        this.emoji = emoji;
        this.damage = options.damage;
        this.area = options.area;
        this.fallbackHeal = options.fallbackHeal;
      }
    }

    // ---------------- æ­¦å™¨ã‚¢ã‚¤ãƒ†ãƒ  ----------------
    class WeaponItem extends InventoryItem {
      constructor(x, y, name, tile, bonus) {
        super(x, y, name, tile, (game) => {
          if (game.player.weapon === this) {
            // è£…å‚™ã‚’è§£é™¤ã™ã‚‹
            this.unEquip(game);
          } else if (game.player.weapon) {
            // ä»Šã®è£…å‚™ã‚’è§£é™¤ã™ã‚‹
            this.unEquip(game, game.player.weapon);
            // é¸æŠã—ãŸæ­¦å™¨ã‚’è£…å‚™ã™ã‚‹
            game.queueTimeout(() => {
              this.equip(game);
            }, 400);
          } else {
            // è£…å‚™ã™ã‚‹
            this.equip(game);
          }
        });
        this.bonus = bonus;
      }
      
      // è£…å‚™ã™ã‚‹
      equip(game, weapon=this) {
        game.player.weapon = weapon;
        game.player.attack += weapon.bonus;
        EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, `æ­¦å™¨è£…å‚™+${weapon.bonus}`, "heal");
      }
      // è£…å‚™è§£é™¤
      unEquip(game, weapon=this) {
        game.player.attack -= game.player.weapon.bonus;
        game.player.weapon = null;
        EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, `è£…å‚™è§£é™¤-${weapon.bonus}`, "damage-me");
      }
    }

    // ---------------- DungeonMap Class ----------------
    class DungeonMap {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.grid = [];
        this.visible = [];
        this.rooms = [];
        this.reset();
      }
      reset() {
        this.grid = Array.from({ length: this.height }, () => Array(this.width).fill(MAP_TILE.WALL));
        this.visible = Array.from({ length: this.height }, () => Array(this.width).fill(false));
        this.rooms = [];
      }
      createRoom() {
        let w = randomInt(5, 10);
        let h = randomInt(4, 8);
        let x = randomInt(1, this.width - w - 1);
        let y = randomInt(1, this.height - h - 1);
        for (let i = y; i < y + h; i++) {
          for (let j = x; j < x + w; j++) {
            this.grid[i][j] = ' ';
          }
        }
        this.rooms.push({ x, y, w, h });
      }
      connectRooms(r1, r2) {
        let x1 = r1.x + Math.floor(r1.w / 2);
        let y1 = r1.y + Math.floor(r1.h / 2);
        let x2 = r2.x + Math.floor(r2.w / 2);
        let y2 = r2.y + Math.floor(r2.h / 2);
        while (x1 !== x2) {
          if (this.grid[y1][x1] === MAP_TILE.WALL) this.grid[y1][x1] = ' ';
          x1 += (x2 > x1) ? 1 : -1;
        }
        while (y1 !== y2) {
          if (this.grid[y1][x1] === MAP_TILE.WALL) this.grid[y1][x1] = ' ';
          y1 += (y2 > y1) ? 1 : -1;
        }
      }
      generate() {
        this.reset();
        const roomCount = (CONFIG.DIFFICULTY === "hard") ? randomInt(5, 8) : randomInt(3, 6);
        for (let i = 0; i < roomCount; i++) { this.createRoom(); }
        for (let i = 0; i < this.rooms.length - 1; i++) { this.connectRooms(this.rooms[i], this.rooms[i + 1]); }
      }
      revealRoom(px, py) {
        for (let room of this.rooms) {
          if (px >= room.x && px < room.x + room.w && py >= room.y && py < room.y + room.h) {
            for (let i = room.y; i < room.y + room.h; i++) {
              for (let j = room.x; j < room.x + room.w; j++) {
                this.visible[i][j] = true;
                const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                for (let [dx, dy] of dirs) {
                  let nx = j + dx, ny = i + dy;
                  if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && this.grid[ny][nx] === ' ') {
                    this.visible[ny][nx] = true;
                  }
                }
              }
            }
            return;
          }
        }
      }
      revealAround(x, y) {
        if (this.grid[y][x] === ' ') {
          for (let dy = -CONFIG.REVEALLV; dy <= CONFIG.REVEALLV; dy++) {
            for (let dx = -CONFIG.REVEALLV; dx <= CONFIG.REVEALLV; dx++) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                this.visible[ny][nx] = true;
              }
            }
          }
        }
      }
    }

    // ---------------- UIManager Class ----------------
    class UIManager {
      constructor() {
        this.hpBar = document.getElementById("hp-bar");
        this.hungerBar = document.getElementById("hunger-bar");
      }
      update(player) {
        this.hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        this.hpBar.textContent = `${player.hp}/${player.maxHp}`;
        this.hungerBar.style.width = `${(player.hunger / player.maxHunger) * 100}%`;
        this.hungerBar.textContent = `${player.hunger}/${player.maxHunger}`;
        if (player.hp > player.maxHp / 2) this.hpBar.style.backgroundColor = "green";
        else if (player.hp > player.maxHp / 4) this.hpBar.style.backgroundColor = "orange";
        else this.hpBar.style.backgroundColor = "red";
      }
    }

    // ---------------- EffectsManager Class ----------------
    class EffectsManager {
      static showEffect(container, player, x, y, text, type = "damage") {
        const dx = x - player.x;
        const dy = y - player.y;
        const spans = container.children;
        const index = (8 + dy) * 16 + (7 + dx);
        if (!spans[index]) return;
        const target = spans[index];
        const rect = target.getBoundingClientRect();
        const fx = document.createElement("div");
        fx.className = type;
        fx.textContent = text;
        if (type === "explosion") {
          fx.style.left = `${rect.left + rect.width / 2 + window.scrollX}px`;
          fx.style.top = `${rect.top + window.scrollY - rect.height * 0.6 + 30}px`;
        } else {
          fx.style.left = `${rect.left + rect.width / 2 + window.scrollX + randomInt(-30, 30)}px`;
          fx.style.top = `${rect.top + window.scrollY - rect.height * 0.6}px`;
        }
        document.body.appendChild(fx);
        setTimeout(() => fx.remove(), 1000);
      }
      static showMagicEffect(container, player, centerX, centerY, area, emoji) {
        for (let dy = -area; dy <= area; dy++) {
          for (let dx = -area; dx <= area; dx++) {
            const x = centerX + dx;
            const y = centerY + dy;
            if (!(x === centerX && y === centerY)) {
              const spans = container.children;
              const index = (8 + (y - player.y)) * 16 + (7 + (x - player.x));
              if (!spans[index]) continue;
              const target = spans[index];
              const rect = target.getBoundingClientRect();
              const fx = document.createElement("div");
              fx.className = "magic-particle";
              fx.textContent = emoji;
              fx.style.left = `${rect.left + rect.width / 2 + window.scrollX + randomInt(-8, 8)}px`;
              fx.style.top = `${rect.top + window.scrollY - rect.height / 2 + randomInt(-8, 8)}px`;
              document.body.appendChild(fx);
              setTimeout(() => fx.remove(), 800);
            }
          }
        }
      }
    }

    // ---------------- InputManager Class ----------------
    class InputManager {
      constructor(game) {
        this.game = game;
        this.init();
      }
      init() {
        document.addEventListener('keydown', (e) => {
          this.game.keysDown[e.key] = true;
          this.game.processInput(e);
        });
        document.addEventListener('keyup', (e) => {
          this.game.keysDown[e.key] = false;
        });
      }
    }

    // ---------------- Game Class ----------------
    class Game {
      constructor() {
        this.actionCount = 0;
        this.actionTime = 400;
        this.width = CONFIG.WIDTH;
        this.height = CONFIG.HEIGHT;
        this.initialHP = CONFIG.INITIAL_HP;
        this.floor = 1;
        this.score = 0;
        this.isGameOver = false;
        this.generateEnemyCycle = [0, CONFIG.GENERATE_ENEMY_CYCLE];
        this.restCycle = [0, CONFIG.REST_CYCLE];
        this.hungerCycle = [0, CONFIG.HUNGER_CYCLE];
        this.timeoutQueue = [];
        this.acceptingInput = true;
        this.keysDown = {};
        this.items = [];
        this.gems = [];
        this.enemies = [];
        this.stairs = { x: 0, y: 0 };
        this.player = new Player(0, 0, this.initialHP);
        this.uiManager = new UIManager();
        this.map = new DungeonMap(this.width, this.height);
        this.gameContainer = document.getElementById("game");
        this.minimapContainer = document.getElementById("minimap");
        this.inventoryOpen = false;
        this.inventorySelection = 0;
        document.getElementById("restCycle").innerText = CONFIG.REST_CYCLE;
        this.generateDungeon(false);
        this.render();
        setTimeout(() => {
          new InputManager(this);
        }, 300);
      }
      
      // ---------------- ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ ----------------
      queueTimeout(callback, delay) {
        this.acceptingInput = false;
        const id = setTimeout(() => {
          callback();
          this.timeoutQueue = this.timeoutQueue.filter(t => t !== id);
          if (this.timeoutQueue.length === 0) this.acceptingInput = true;
          this.render();
        }, delay);
        this.timeoutQueue.push(id);
      }
      
      // ---------------- ã‚²ãƒ¼ãƒ é€²è¡Œåˆ¶å¾¡ ----------------
      advanceTurn() {
        this.generateEnemyCycle[0] = (this.generateEnemyCycle[0] + 1) % this.generateEnemyCycle[1];
        this.hungerCycle[0] = (this.hungerCycle[0] + 1) % this.hungerCycle[1];
      }
      updateData(inputResult) {
        if (!inputResult) return;
        this.actionCount = 0;
        const { tx, ty } = inputResult;
        let attacked = false;
        for (let i = 0; i < this.enemies.length; i++) {
          if (this.enemies[i].x === tx && this.enemies[i].y === ty) {
            attacked = true;
            this.damageEnemy(this.enemies[i], i);
            break;
          }
        }
        if (!attacked && this.map.grid[ty]?.[tx] !== MAP_TILE.WALL &&
            !this.enemies.some(e => e.x === tx && e.y === ty)) {
          this.player.x = tx;
          this.player.y = ty;
          this.map.visible[ty][tx] = true;
          this.map.revealRoom(tx, ty);
          this.map.revealAround(tx, ty);
        }
        if (this.player.x === this.stairs.x && this.player.y === this.stairs.y) {
          this.generateDungeon(true);
          return;
        }
        this.items = this.items.filter(item => {
          if (item.x === this.player.x && item.y === this.player.y) {
            if (this.player.inventory.length < CONFIG.INVENTORY_MAX) {
              this.player.inventory.push(item);
              EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, "GET");
              return false;
            }
          }
          return true;
        });
        this.checkHunger();
        if (attacked) {
          this.enemyAttackPhase();
          this.queueTimeout(() => {
            this.enemyMovementPhase(tx, ty, attacked);
            this.enemyActionRefresh();
          }, (this.actionCount + 1) * this.actionTime);
        } else {
          this.enemyMovementPhase(tx, ty);
          this.enemyAttackPhase();
          this.queueTimeout(() => { this.enemyActionRefresh(); }, this.actionCount * this.actionTime);
        }
        this.checkCollisions();
        if (this.generateEnemyCycle[0] === 0) {
          this.placeEntities(this.enemies, randomInt(1, 3), "enemy");
        }
      }
      computeInput(event) {
        // å›å¾©ã‚µã‚¤ã‚¯ãƒ«
        if (this.keysDown['ArrowLeft'] ||
            this.keysDown['ArrowRight'] ||
            this.keysDown['ArrowUp'] ||
            this.keysDown['ArrowDown'] ||
            event.key === '.') {
          this.restCycle[0] = (this.restCycle[0] + 1) % this.restCycle[1];
          if (this.restCycle[0] === 0 && this.player.hp < this.player.maxHp) this.player.hp++;
        }
        
        if (this.keysDown['Shift']) {
          let hor = 0, ver = 0;
          if (this.keysDown['ArrowLeft'] && !this.keysDown['ArrowRight']) { hor = -1; }
          else if (this.keysDown['ArrowRight'] && !this.keysDown['ArrowLeft']) { hor = 1; }
          if (this.keysDown['ArrowUp'] && !this.keysDown['ArrowDown']) { ver = -1; }
          else if (this.keysDown['ArrowDown'] && !this.keysDown['ArrowUp']) { ver = 1; }
          if (hor !== 0 && ver !== 0) {
            if (this.map.grid[this.player.y][this.player.x + hor] === MAP_TILE.WALL ||
                this.map.grid[this.player.y + ver][this.player.x] === MAP_TILE.WALL) return null;
            return { tx: this.player.x + hor, ty: this.player.y + ver };
          }
          return null;
        }
        if (event.key === '.') {
          return { tx: this.player.x, ty: this.player.y };
        }
        if (event.key === 'r') { this.showResults(); return null; }
        let dx = 0, dy = 0, count = 0;
        if (this.keysDown['ArrowLeft']) { dx = -1; count++; }
        if (this.keysDown['ArrowRight']) { dx = 1; count++; }
        if (this.keysDown['ArrowUp']) { dy = -1; count++; }
        if (this.keysDown['ArrowDown']) { dy = 1; count++; }
        if (count === 1) {
          if (this.map.grid[this.player.y + dy]?.[this.player.x + dx] === MAP_TILE.WALL) return null;
          return { tx: this.player.x + dx, ty: this.player.y + dy };
        }
        return null;
      }
      // processInventoryInput() ã¨ processInput() ã¯å¾“æ¥é€šã‚Š
      processInventoryInput(event) {
        if (event.key === 'ArrowUp') {
          if (this.player.inventory.length > 0) {
            this.inventorySelection = (this.inventorySelection - 1 + this.player.inventory.length) % this.player.inventory.length;
            this.render();
          }
          return;
        }
        if (event.key === 'ArrowDown') {
          if (this.player.inventory.length > 0) {
            this.inventorySelection = (this.inventorySelection + 1) % this.player.inventory.length;
            this.render();
          }
          return;
        }
        if (event.key === 'u') {
          let item = this.player.inventory[this.inventorySelection];
          if (item && item.use) {
            item.use(this);
            // æ­¦å™¨ã¯æ¶ˆè²»ã—ãªã„
            if (item.name.match(/æ­¦å™¨.*/g) === null) {
              this.player.inventory.splice(this.inventorySelection, 1);
              if (this.inventorySelection >= this.player.inventory.length) {
                this.inventorySelection = this.player.inventory.length - 1;
              }
            }
            this.advanceTurn();
            this.enemyMovementPhase(this.player.x, this.player.y);
            this.enemyAttackPhase();
            this.checkCollisions();
          }
          this.inventoryOpen = false;
          this.render();
          return;
        }
        if (event.key === 'd') {
          let item = this.player.inventory[this.inventorySelection];
          if (item) {
            if (item.name.match(/æ­¦å™¨.*/g) && this.player.weapon === item) {
              this.player.attack -= this.player.weapon.bonus;
              this.player.weapon = null;
              EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `è£…å‚™è§£é™¤-${item.bonus}`, "heal");
            }
            item.x = this.player.x;
            item.y = this.player.y;
            this.items.push(item);
            this.player.inventory.splice(this.inventorySelection, 1);
            if (this.inventorySelection >= this.player.inventory.length) {
              this.inventorySelection = this.player.inventory.length - 1;
            }
          }
          this.inventoryOpen = false;
          this.render();
          return;
        }
        if (event.key === 'Escape' || event.key === 'e') {
          this.inventoryOpen = false;
          this.render();
          return;
        }
      }
      processInput(event) {
        if (this.isGameOver || !this.acceptingInput) return;
        if (event.key === 'e') {
          this.inventoryOpen = !this.inventoryOpen;
          if (this.inventoryOpen) this.inventorySelection = 0;
          this.render();
          return;
        }
        if (this.inventoryOpen) {
          this.processInventoryInput(event);
          return;
        }
        const inputResult = this.computeInput(event);
        if (!inputResult) return;
        this.advanceTurn();
        this.updateData(inputResult);
        this.render();
      }
      
      // ---------------- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–¢é€£ ----------------
      findPath(startX, startY, targetX, targetY) {
        let queue = [];
        queue.push({ x: startX, y: startY, path: [] });
        let visited = new Set();
        visited.add(`${startX},${startY}`);
        const directions = [
          { dx: 1, dy: 0 },
          { dx: -1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: 0, dy: -1 },
          { dx: 1, dy: 1 },
          { dx: -1, dy: -1 },
          { dx: 1, dy: -1 },
          { dx: -1, dy: 1 }
        ];
        while (queue.length > 0) {
          const current = queue.shift();
          if (current.x === targetX && current.y === targetY) return current.path;
          for (const d of directions) {
            const nx = current.x + d.dx;
            const ny = current.y + d.dy;
            if (nx < 0 || ny < 0 || nx >= this.width || ny >= this.height) continue;
            if (this.map.grid[ny][nx] === MAP_TILE.WALL) continue;
            const key = `${nx},${ny}`;
            if (!visited.has(key)) {
              visited.add(key);
              queue.push({ x: nx, y: ny, path: current.path.concat([{ x: nx, y: ny }]) });
            }
          }
        }
        return null;
      }
      checkCollisions() {
        this.gems = this.gems.filter(gem => {
          if (gem.x === this.player.x && gem.y === this.player.y) {
            this.score += 100;
            EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, "+100");
            return false;
          }
          return true;
        });
        setTimeout(() => {
          if (this.player.hp <= 0) {
            this.saveResult();
            this.player = new Player(0, 0, this.initialHP);
            this.isGameOver = true;
            this.timeoutQueue.forEach(id => clearTimeout(id));
            this.timeoutQueue = [];
            this.acceptingInput = true;
            this.restCycle[0] = 0;
            this.generateEnemyCycle[0] = 0;
            this.hungerCycle[0] = 0;
            alert("å€’ã‚Œã¦ã—ã¾ã£ãŸï¼");
            new DifficultySelector();
            delete(this);
          }
        }, this.actionCount * this.actionTime);
      }
      onHeal() {
        this.player.hp += this.player.healAmount;
        if (this.player.hp > this.player.maxHp) this.player.hp = this.player.maxHp;
        EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `+${this.player.healAmount}`, "heal");
      }
      gainExp(amount) {
        this.player.exp += amount;
        const expToNext = this.player.level * 10;
        if (this.player.exp >= expToNext) {
          let upAtk, upHp;
          this.player.exp -= expToNext;
          this.player.level++;
          this.player.attack += (upAtk = randomInt(1, 2));
          this.player.maxHp += (upHp = randomInt(2, 3));
          this.player.healAmount++;
          this.player.hp = this.player.maxHp;
          EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, "LEVEL UP!", "heal");
          this.queueTimeout(() => { EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `HP +${upHp}`, "heal"); }, 500);
          this.queueTimeout(() => { EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `æ”»æ’ƒåŠ› +${upAtk}`, "heal"); }, 1000);
        }
      }
      playerEat(amount) {
        this.player.hunger += amount;
        if (this.player.hunger > this.player.maxHunger) this.player.hunger = this.player.maxHunger;
        EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `+${amount}`, "food");
      }
      checkHunger() {
        this.hungerCycle[0] = (this.hungerCycle[0] + 1) % this.hungerCycle[1];
        if (this.hungerCycle[0] === 0) { this.player.hunger--; if (this.player.hunger < 0) this.player.hunger = 0; }
        if (this.player.hunger === 0) { this.player.hp--; EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, "é¤“æ­»", "damage"); }
      }
      
      // ---------------- æ•µé–¢é€£ ----------------
      // æ•µã®ç§»å‹•å‡¦ç†
      enemyMovementPhase(nextPlayerX, nextPlayerY, attacked=false) {
        // æ•µãŒå æœ‰ã—ã¦ã„ã‚‹åº§æ¨™ã‚’ç®¡ç†ã™ã‚‹ã‚»ãƒƒãƒˆã‚’ä½œæˆ
        let occupied = new Set();
        // ã™ã¹ã¦ã®æ•µã®ç¾åœ¨ä½ç½®ã‚’ occupied ã«è¿½åŠ 
        this.enemies.forEach(e => occupied.add(`${e.x},${e.y}`));
      
        // å„æ•µã«ã¤ã„ã¦ç§»å‹•å‡¦ç†ã‚’è¡Œã†
        this.enemies.forEach((enemy) => {
          // ä½“åŠ›ãŒ0ä»¥ä¸‹ã€ã¾ãŸã¯è¡Œå‹•å›æ•°ãŒ0ãªã‚‰å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
          if (enemy.hp <= 0 || enemy.action === 0) return;
      
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’æ°´å¹³æ–¹å‘(dx)ãƒ»å‚ç›´æ–¹å‘(dy)ã§ç®—å‡º
          let dx = Math.abs(enemy.x - this.player.x);
          let dy = Math.abs(enemy.y - this.player.y);
      
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®éš£æ¥ï¼ˆä¸Šä¸‹å·¦å³ï¼‰ãªã‚‰ç§»å‹•ä¸è¦ãªã®ã§å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
          if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) return;
          // æ–œã‚éš£ã®å ´åˆã€å£ãŒé–“ã«ç„¡ã‘ã‚Œã°ç§»å‹•ã—ãªã„
          else if (dx === 1 && dy === 1) {
            if (this.map.grid[this.player.y][enemy.x] !== MAP_TILE.WALL &&
                this.map.grid[enemy.y][this.player.x] !== MAP_TILE.WALL) return;
          }
      
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¾ã§ã®æœ€çŸ­çµŒè·¯ã‚’æ¢ç´¢
          const path = this.findPath(enemy.x, enemy.y, this.player.x, this.player.y);
          if (path && path.length > 0) {
            // çµŒè·¯ã®æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å€™è£œä½ç½®ã¨ã™ã‚‹
            let candidate = path[0];
            
            // æ•µãŒå€™è£œä½ç½®ã«æ–œã‚ç§»å‹•ã™ã‚‹å ´åˆã®ãƒã‚§ãƒƒã‚¯
            if (enemy.x !== candidate.x && enemy.y !== candidate.y) {
              // å€™è£œä½ç½®ã¸ã®æ°´å¹³ç§»å‹•ãŒå£ã§å¡ãŒã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
              const horizontalBlocked = (this.map.grid[enemy.y][candidate.x] === MAP_TILE.WALL);
              // å€™è£œä½ç½®ã¸ã®å‚ç›´ç§»å‹•ãŒå£ã§å¡ãŒã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
              const verticalBlocked = (this.map.grid[candidate.y][enemy.x] === MAP_TILE.WALL);
              // ã©ã¡ã‚‰ã‹ãŒå¡ãŒã‚Œã¦ã„ã‚‹å ´åˆã€åˆ¥ã®ç§»å‹•å€™è£œã‚’æ¤œè¨ã™ã‚‹
              if (horizontalBlocked || verticalBlocked) {
                let possibleMoves = [];
                // æ°´å¹³æ–¹å‘ã«å¡ãŒã‚Œã¦ã„ãªã‘ã‚Œã°ã€æ°´å¹³ç§»å‹•ã®å€™è£œã‚’è¿½åŠ 
                if (!horizontalBlocked) possibleMoves.push({ x: candidate.x, y: enemy.y });
                // å‚ç›´æ–¹å‘ã«å¡ãŒã‚Œã¦ã„ãªã‘ã‚Œã°ã€å‚ç›´ç§»å‹•ã®å€™è£œã‚’è¿½åŠ 
                if (!verticalBlocked) possibleMoves.push({ x: enemy.x, y: candidate.y });
                // å€™è£œã‚’ä¸€æ—¦ã‚¯ãƒªã‚¢
                candidate = null;
                // å¯èƒ½ãªç§»å‹•å€™è£œã‹ã‚‰ç©ºã„ã¦ã„ã‚‹å ´æ‰€ã‚’æ¢ã™
                for (let move of possibleMoves) {
                  if (!occupied.has(`${move.x},${move.y}`)) {
                    candidate = move;
                    break;
                  }
                }
                // ç§»å‹•å€™è£œãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€ã“ã®æ•µã¯ç§»å‹•ã—ãªã„
                if (!candidate) return;
              }
            }
            // ãã®å€™è£œä½ç½®ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ¬¡ã®ç§»å‹•å…ˆã¨ä¸€è‡´ã—ã¦ã„ã‚Œã°ç§»å‹•ã—ãªã„
            if (!attacked && candidate.x === nextPlayerX && candidate.y === nextPlayerY) return;
            // å€™è£œä½ç½®ãŒæ—¢ã«ä»–ã®æ•µã«å æœ‰ã•ã‚Œã¦ã„ã‚‹å ´åˆã€ç§»å‹•ã—ãªã„
            if (occupied.has(`${candidate.x},${candidate.y}`)) return;
            // ç¾åœ¨ã®ä½ç½®ã‚’ occupied ã‹ã‚‰å‰Šé™¤
            occupied.delete(`${enemy.x},${enemy.y}`);
            // è¡Œå‹•å›æ•°ã‚’1æ¸›ã‚‰ã™
            enemy.action--;
            // æ•µã®åº§æ¨™ã‚’å€™è£œä½ç½®ã«æ›´æ–°
            enemy.x = candidate.x;
            enemy.y = candidate.y;
            // æ–°ã—ã„ä½ç½®ã‚’ occupied ã«è¿½åŠ 
            occupied.add(`${enemy.x},${enemy.y}`);
          }
        });
      }
      
      // æ•µã®æ”»æ’ƒå‡¦ç†
      enemyAttackPhase() {
        // å„æ•µã«ã¤ã„ã¦æ”»æ’ƒå‡¦ç†ã‚’è¡Œã†
        this.enemies.forEach((enemy) => {
          // ä½“åŠ›ãŒ0ä»¥ä¸‹ã€ã¾ãŸã¯è¡Œå‹•å›æ•°ãŒ0ãªã‚‰æ”»æ’ƒã‚’è¡Œã‚ãªã„
          if (enemy.hp <= 0 || enemy.action === 0) {
            this.x = this.y = -1;
            return;
          }
      
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ã‚’æ°´å¹³æ–¹å‘(dx)ãƒ»å‚ç›´æ–¹å‘(dy)ã§ç®—å‡º
          const dx = Math.abs(enemy.x - this.player.x);
          const dy = Math.abs(enemy.y - this.player.y);
      
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒä¸Šä¸‹å·¦å³ã«éš£æ¥ã—ã¦ã„ã‚‹å ´åˆ
          if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
            // æ•µã®è¡Œå‹•å›æ•°ã‚’1æ¸›ã‚‰ã™
            enemy.action--;
            // é…å»¶ã‚’åŠ ãˆã¦æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ãƒ€ãƒ¡ãƒ¼ã‚¸åæ˜ ã®å‡¦ç†ã‚’è¡Œã†
            this.queueTimeout(() => {
              this.player.hp -= enemy.atk;
              if (this.player.hp < 0) this.player.hp = 0;
              // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¡¨ç¤º
              EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `-${enemy.atk}`, "damage-me");
            }, this.actionCount * this.actionTime);
            // æ¬¡ã®æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãŸã‚ã« actionCount ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
            this.actionCount++;
          }
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ–œã‚ã«éš£æ¥ã—ã¦ã„ã‚‹å ´åˆ
          else if (dx === 1 && dy === 1) {
            // éš£æ¥ã™ã‚‹æ–œã‚æ–¹å‘ã®ç§»å‹•çµŒè·¯ã«å£ãŒãªã‘ã‚Œã°æ”»æ’ƒã™ã‚‹
            if (this.map.grid[this.player.y][enemy.x] !== MAP_TILE.WALL &&
                this.map.grid[enemy.y][this.player.x] !== MAP_TILE.WALL) {
              // æ•µã®è¡Œå‹•å›æ•°ã‚’1æ¸›ã‚‰ã™
              enemy.action--;
              // é…å»¶ã‚’åŠ ãˆã¦æ”»æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ãƒ€ãƒ¡ãƒ¼ã‚¸åæ˜ ã®å‡¦ç†ã‚’å®Ÿæ–½
              this.queueTimeout(() => {
                this.player.hp -= enemy.atk;
                if (this.player.hp < 0) this.player.hp = 0;
                // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¡¨ç¤º
                EffectsManager.showEffect(this.gameContainer, this.player, this.player.x, this.player.y, `-${enemy.atk}`, "damage-me");
              }, this.actionCount * this.actionTime);
              // æ¬¡ã®æ”»æ’ƒã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãŸã‚ã« actionCount ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
              this.actionCount++;
            }
          }
        });
      }
      enemyActionRefresh() {
        this.enemies.forEach((enemy) => { enemy.action = enemy.maxAction; });
      }
      damageEnemy(enemy, index) {
        enemy.takeDamage(this.player.attack);
        EffectsManager.showEffect(this.gameContainer, this.player, enemy.x, enemy.y, `-${this.player.attack}`, "damage");
        this.actionCount++;
        if (enemy.hp <= 0) {
          EffectsManager.showEffect(this.gameContainer, this.player, enemy.x, enemy.y, "ğŸ’¥", "explosion");
          this.enemies.splice(index, 1);
          this.score += 50;
          this.gainExp(5);
        }
      }
      
      // ---------------- ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° ----------------
      renderMainView() {
        let html = '';
        const radius = CONFIG.VIEW_RADIUS;
        const startX = this.player.x - radius;
        const startY = this.player.y - radius;
        for (let y = startY; y <= this.player.y + radius; y++) {
          for (let x = startX; x <= this.player.x + radius; x++) {
            let tile = MAP_TILE.WALL;
            if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
              if (!this.map.visible[y][x]) { html += `<span class="wall">${MAP_TILE.WALL}</span>`; continue; }
              else if (this.player.x === x && this.player.y === y) tile = this.player.tile;
              else {
                let drawn = false;
                for (let enemy of this.enemies) {
                  if (enemy.x === x && enemy.y === y) { tile = enemy.tile; drawn = true; break; }
                }
                if (!drawn) {
                  for (let item of this.items) {
                    if (item.x === x && item.y === y) { tile = item.tile; drawn = true; break; }
                  }
                  for (let gem of this.gems) {
                    if (gem.x === x && gem.y === y) { tile = 'ğŸ’'; drawn = true; break; }
                  }
                  if (!drawn && this.stairs.x === x && this.stairs.y === y) tile = MAP_TILE.STEPS;
                  if (!drawn && tile === MAP_TILE.WALL) tile = this.map.grid[y][x];
                }
              }
            }
            html += `<span>${tile}</span>`;
          }
          html += '<br>';
        }
        this.gameContainer.innerHTML = html;
      }
      renderMinimap() {
        let html = '';
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            let style = "";
            if (this.map.visible[y][x]) {
              if (this.player.x === x && this.player.y === y) style = "background-color: yellow;";
              else if (this.enemies.some(e => e.x === x && e.y === y)) style = "background-color: red;";
              else if (this.items.some(item => item.x === x && item.y === y)) style = "background-color: cyan;";
              else if (this.stairs.x === x && this.stairs.y === y) style = "border: 1px solid cyan; background-color: transparent;";
              else style = (this.map.grid[y][x] === ' ') ? "background-color: #555;" : "background-color: #222;";
            }
            html += `<div class="minimap-cell" style="${style}"></div>`;
          }
        }
        this.minimapContainer.innerHTML = html;
        this.minimapContainer.style.gridTemplateColumns = `repeat(${this.width}, 4px)`;
      }
      render() {
        document.body.classList.remove("easy-dungeon", "hard-dungeon", "deep-dungeon");
        if (this.floor < 10) document.body.classList.add("easy-dungeon");
        else if (this.floor < 50) document.body.classList.add("hard-dungeon");
        else document.body.classList.add("deep-dungeon");
        this.renderMainView();
        this.renderMinimap();
        document.getElementById('difficulty').innerText = CONFIG.DIFFICULTY;
        document.getElementById('hp').innerText = this.player.hp;
        document.getElementById('maxhp').innerText = this.player.maxHp;
        document.getElementById('atk').innerText = this.player.attack;
        document.getElementById('lv').innerText = this.player.level;
        document.getElementById('exp').innerText = this.player.exp;
        document.getElementById('floor').innerText = this.floor;
        document.getElementById('score').innerText = this.score;
        document.getElementById('hunger').innerText = this.player.hunger;
        document.getElementById('maxhunger').innerText = this.player.maxHunger;
        this.uiManager.update(this.player);
        if (this.inventoryOpen) {
          let invHtml = `<div class="inventory-modal">`;
          invHtml += `<h3>æ‰€æŒå“ (${this.player.inventory.length}/${CONFIG.INVENTORY_MAX})</h3>`;
          if (this.player.inventory.length === 0) invHtml += `<p>(ãªã—)</p>`;
          else {
            invHtml += `<ul>`;
            for (let i = 0; i < this.player.inventory.length; i++) {
              let selected = (i === this.inventorySelection) ? ">> " : "";
              let itemName = this.player.inventory[i].name || "ã‚¢ã‚¤ãƒ†ãƒ ";
              if (this.player.inventory[i].name.match(/æ­¦å™¨.*/g) && this.player.weapon === this.player.inventory[i])
                itemName += " (è£…å‚™ä¸­)";
              invHtml += `<li class="${(i===this.inventorySelection) ? 'selected' : ''}">${selected}${itemName}</li>`;
            }
            invHtml += `</ul>`;
            invHtml += `<p>u: ä½¿ç”¨, d: ç½®ã, Esc/e: é–‰ã˜ã‚‹</p>`;
          }
          invHtml += `</div>`;
          this.gameContainer.innerHTML += invHtml;
        }
      }
      
      // ---------------- ãƒªã‚¶ãƒ«ãƒˆ ----------------
      saveResult(clear=false) {
        let results = JSON.parse(localStorage.getItem("gameResult") || "[]");
        results.push({
          date: new Date().toISOString(),
          dungeonLv: CONFIG.DIFFICULTY,
          floor: this.floor,
          clear: clear,
          lv: this.player.level,
          score: this.score
        });
        localStorage.setItem("gameResult", JSON.stringify(results));
      }
      showResults() {
        let results = JSON.parse(localStorage.getItem("gameResult") || "[]");
        let modalHtml = '<div class="results-modal" id="resultsModal">';
        modalHtml += '<h3>è¨˜éŒ²ã•ã‚ŒãŸçµæœ</h3>';
        if(results.length === 0) modalHtml += '<p>è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
        else {
          modalHtml += '<table><tr><th>æ—¥ä»˜</th><th>é›£æ˜“åº¦</th><th>ãƒ•ãƒ­ã‚¢</th><th>çµæœ</th><th>ãƒ¬ãƒ™ãƒ«</th><th>ã‚¹ã‚³ã‚¢</th></tr>';
          results.forEach(r => {
            modalHtml += `<tr><td>${new Date(r.date).toLocaleString()}</td><td>${r.dungeonLv == undefined ? "-" : r.dungeonLv}</td><td>${r.floor}</td><td>${r.clear ? "ã‚¯ãƒªã‚¢" : "ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼"}</td><td>${r.lv}</td><td>${r.score}</td></tr>`;
          });
          modalHtml += '</table>';
        }
        modalHtml += '<button onclick="closeResults()">é–‰ã˜ã‚‹</button>';
        modalHtml += '</div>';
        const existingModal = document.getElementById("resultsModal");
        if (!existingModal) {
          const modalDiv = document.createElement("div");
          modalDiv.innerHTML = modalHtml;
          document.body.appendChild(modalDiv);
        }
      }
      
      // ---------------- ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ç”Ÿæˆ ----------------
      generateDungeon(keepHP = false) {
        const prevHP = this.player.hp;
        const prevScore = this.score;
        this.map.generate();
        this.enemies = [];
        this.items = [];
        this.gems = [];
        const firstRoom = this.map.rooms[0];
        this.player.x = firstRoom.x + 1;
        this.player.y = firstRoom.y + 1;
        this.map.revealRoom(this.player.x, this.player.y);
        this.map.revealAround(this.player.x, this.player.y);
        if (!keepHP) {
          this.player.hp = this.initialHP;
          this.score = 0;
          this.floor = 1;
          this.player.hunger = this.player.maxHunger;
        } else {
          this.player.hp = prevHP;
          this.score = prevScore;
          this.floor++;
          // ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é›£æ˜“åº¦ã«åˆã‚ã›ãŸæœ€çµ‚ãƒ•ãƒ­ã‚¢ãƒã‚§ãƒƒã‚¯
          console.log(difficultySettings)
          console.log(CONFIG.DIFFICULTY)
          if (this.floor > difficultySettings[CONFIG.DIFFICULTY].maxFloor) {
            alert("ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ï¼");
            this.player = new Player(0, 0, this.initialHP);
            this.floor = 1;
            this.score = 0;
            this.generateDungeon(false);
            return;
          }
        }
        const lastRoom = this.map.rooms.at(-1);
        this.stairs.x = lastRoom.x + 2;
        this.stairs.y = lastRoom.y + 2;
        this.map.grid[this.stairs.y][this.stairs.x] = MAP_TILE.STEPS;
        // æ•µã®å¼·ã•å€ç‡ã‚’é›£æ˜“åº¦ã§èª¿æ•´
        if (CONFIG.DIFFICULTY === "hard") {
          this.minMagnification = 1.4;
          this.maxMagnification = 1.7;
        } else {
          this.minMagnification = CONFIG.MIN_ENEMY_MULTIPLIER;
          this.maxMagnification = CONFIG.MAX_ENEMY_MULTIPLIER;
        }
        
        this.placeEntities(this.enemies, randomInt(2, 4), "enemy");
        this.placeEntities(this.gems, randomInt(1, 2), "entity");
        
        const maxItems = randomInt(3, 5);
        const weightedTypes = [
          ...Array(2).fill("food"),
          ...Array(2).fill("sushi"),
          ...Array(1).fill("magic"),
          ...Array(1).fill("niku"),
          ...Array(2).fill("weapon")
        ];
        
        for (let i = 0; i < maxItems; i++) {
          const type = weightedTypes.splice(randomInt(0, weightedTypes.length - 1), 1)[0];
          this.placeEntities(this.items, 1, type);
        }
      }
      placeEntities(arr, count, type) {
        for (let i = 0; i < count; i++) {
          let x, y, hp;
          do {
            const room = this.map.rooms[randomInt(0, this.map.rooms.length - 1)];
            x = randomInt(room.x + 1, room.x + room.w - 2);
            y = randomInt(room.y + 1, room.y + room.h - 2);
            if (type === "enemy") {
              hp = randomInt(
                Math.round(Math.pow(this.floor, this.minMagnification)),
                Math.round(Math.pow(this.floor, this.maxMagnification))
              );
            }
          } while (this.map.grid[y][x] !== ' ' || (x === this.player.x && y === this.player.y));
          if (type === "sushi") {
            arr.push(new InventoryItem(x, y, "ã™ã—", 'ğŸ£', function(game) {
              game.player.hp += 3;
              if (game.player.hp > game.player.maxHp) game.player.hp = game.player.maxHp;
              EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, "+3", "heal");
            }));
          } else if (type === "niku") {
            arr.push(new InventoryItem(x, y, "ãŠè‚‰", 'ğŸ–', function(game) {
              game.player.hp += 6;
              if (game.player.hp > game.player.maxHp) game.player.hp = game.player.maxHp;
              EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, "+6", "heal");
            }));
          } else if (type === "weapon") {
            const bonus = randomInt(1, 3);
            arr.push(new WeaponItem(x, y, `æ­¦å™¨ (+${bonus})`, 'ğŸ—¡ï¸', bonus));
          } else if (type === "magic") {
            var selection = randomInt(1, 4);
            switch (selection) {
            case 1:
                arr.push(new MagicSpell(x, y, "ç«ã®ç‰", 'ğŸ”¥', 'ğŸ”¥', {damage: 10, area: 1, fallbackHeal: null}));
            	break;
            case 2:
                arr.push(new MagicSpell(x, y, "ãŸã¤ã¾ã", 'ğŸŒªï¸', 'ğŸŒªï¸', {damage: 8, area: 2, fallbackHeal: null}));
            	break;
            case 3:
                arr.push(new MagicSpell(x, y, "å¤§æ³¢", 'ğŸŒŠ', 'ğŸŒŠ', {damage: 5, area: 4, fallbackHeal: null}));
            	break;
            case 4:
                arr.push(new MagicSpell(x, y, "ã‚«ãƒŸãƒŠãƒª", 'âš¡ï¸', 'âš¡ï¸', {damage: 15, area: 1, fallbackHeal: null}));
            	break;
            }
          } else if (type === "entity") {
            arr.push(new BaseEntity(x, y));
          } else if (type === "enemy") {
            const enemys = enemyList(this.floor, CONFIG.DIFFICULTY);
            const EnemyClass = enemys[randomInt(0, enemys.length - 1)];
            arr.push(new EnemyClass(x, y, hp));
          } else if (type === "food") {
            if (Math.random() > 0.7) {
              arr.push(new InventoryItem(x, y, "ãƒ‘ãƒ³", 'ğŸ¥–', function(game) {
                game.player.hunger += 20;
                if (game.player.hunger > game.player.maxHunger) game.player.hunger = game.player.maxHunger;
                EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, "+20", "food");
              }));
            } else {
              arr.push(new InventoryItem(x, y, "å¤§ããªãƒ‘ãƒ³", 'ğŸ', function(game) {
                game.player.hunger += 50;
                if (game.player.hunger > game.player.maxHunger) game.player.hunger = game.player.maxHunger;
                EffectsManager.showEffect(game.gameContainer, game.player, game.player.x, game.player.y, "+50", "food");
              }));
            }
          }
        }
      }
    }

    // ---------------- DifficultySelector ã‚¯ãƒ©ã‚¹ ----------------
    class DifficultySelector {
      constructor() {
        this.gridWidth = 15;
        this.gridHeight = 15;
        this.grid = [];
        for (let y = 0; y < this.gridHeight; y++) {
          this.grid[y] = [];
          for (let x = 0; x < this.gridWidth; x++) {
            this.grid[y][x] = " ";
          }
        }
        // é›£æ˜“åº¦ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®é…ç½®ï¼ˆä¾‹ï¼‰
        this.options = [
          { x: 3, y: 3, difficulty: "easy", tile: difficultySettings.easy.wallEmoji },
          { x: 11, y: 3, difficulty: "normal", tile: difficultySettings.normal.wallEmoji },
          { x: 7, y: 11, difficulty: "hard", tile: difficultySettings.hard.wallEmoji }
        ];
        this.options.forEach(opt => {
          for (var pos of [[-1, 0], [-1, -1], [0, -1], [1, -1], [1, 0]]) {
            this.grid[opt.y + pos[1]][opt.x + pos[0]] = opt.tile;
          }
        });
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸä½ç½®ï¼ˆä¸­å¤®ï¼‰
        this.playerX = Math.floor(this.gridWidth / 2);
        this.playerY = Math.floor(this.gridHeight / 2);
        this.inSelection = true;
        this.render();
        this.handleKeyDown = this.handleKeyDown.bind(this);
        document.addEventListener('keydown', this.handleKeyDown);
      }
      render() {
        let html = "";
        for (let y = 0; y < this.gridHeight; y++) {
          for (let x = 0; x < this.gridWidth; x++) {
            if (x === this.playerX && y === this.playerY) {
              html += "<span>ğŸ˜Š</span>";
            } else {
              html += `<span>${this.grid[y][x]}</span>`;
            }
          }
          html += "<br>";
        }
        document.getElementById("game").innerHTML = html;
      }
      handleKeyDown(e) {
        if (!this.inSelection) return;
        let dx = 0, dy = 0;
        if (e.key === "ArrowLeft") dx = -1;
        else if (e.key === "ArrowRight") dx = 1;
        else if (e.key === "ArrowUp") dy = -1;
        else if (e.key === "ArrowDown") dy = 1;
        if (dx !== 0 || dy !== 0) {
          let newX = this.playerX + dx;
          let newY = this.playerY + dy;
          if (newX < 0 || newX >= this.gridWidth || newY < 0 || newY >= this.gridHeight) return;
          this.playerX = newX;
          this.playerY = newY;
          this.render();
          // é›£æ˜“åº¦ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«åˆ°é”ã—ã¦ã„ã‚Œã°ã‚²ãƒ¼ãƒ é–‹å§‹
          for (let opt of this.options) {
            if (opt.x === this.playerX && opt.y === this.playerY) {
              this.inSelection = false;
              document.removeEventListener('keydown', this.handleKeyDown);
              startDungeonGame(opt.difficulty);
              break;
            }
          }
        }
      }
    }

    // é›£æ˜“åº¦é¸æŠå¾Œã«å‘¼ã°ã‚Œã‚‹
    function startDungeonGame(difficulty) {
      CONFIG.DIFFICULTY = difficulty;
      CONFIG.REVEALLV = difficultySettings[difficulty].revealLv;
      MAP_TILE.WALL = difficultySettings[difficulty].wallEmoji;
      // æ—¢å­˜ã®Gameã‚¯ãƒ©ã‚¹ã‚’èµ·å‹•
      setTimeout(() => { 
        new Game();
      }, 300);
    }

    function closeResults() {
      const modal = document.getElementById("resultsModal");
      if (modal) modal.remove();
    }

    // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆï¼šDifficultySelectorã‹ã‚‰é›£æ˜“åº¦é¸æŠã•ã›ã‚‹
    new DifficultySelector();
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ãƒ­ãƒ¼ã‚°ã£ã½ã„ä½•ã‹ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ç‰ˆï¼‰</title>
<style> body { font-family: monospace; position: relative; } .game-container { font-size: 16px; line-height: 1.2; white-space: pre; position: relative; } .game-container span { display: inline-block; width: 2.2ch; text-align: center; transition: all 0.1s; } .wall { background-color: #C4DD87; display: inline-block; height: 20px; } .hit { background-color: red !important; color: white; } .shake { transform: translateY(-2px); } .damage, .damage-me, .heal, .explosion, .food { position: absolute; font-weight: bold; font-size: 18px; border-radius: 4px; pointer-events: none; transform: translate(-50%, -100%); animation: floatUp 1.0s ease-out forwards; } .damage-me { color: white; background-color: red; padding: 2px 4px; box-shadow: 1px 1px 2px black; } .damage { color: white; background-color: orange; padding: 2px 4px; box-shadow: 1px 1px 2px black; } .heal { color: white; background-color: green; padding: 2px 4px; box-shadow: 1px 1px 2px black; } .food { color: white; background-color: green; padding: 2px 4px; box-shadow: 1px 1px 2px black; } .explosion { color: orange; font-size: 22px; animation: explodeUp 0.4s ease-out forwards; } @keyframes floatUp { 0% { opacity: 1; transform: translate(-50%, -100%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -160%) scale(1.3); } } @keyframes explodeUp { 0% { opacity: 1; transform: translate(-50%, -100%) scale(0.8); } 100% { opacity: 0; transform: translate(-50%, -180%) scale(1.6); } } .bar-container { width: 200px; height: 16px; background-color: #ccc; border: 1px solid #999; border-radius: 20px; margin-bottom: 2px; position: relative; } .bar { height: 100%; border-radius: 20px; text-align: center; color: white; font-size: 12px; line-height: 16px; } .bar.hp { background-color: green; } .bar.hunger { background-color: skyblue; } p { font-size: 16px; line-height: 0.6; } </style>
</head>
<body>
<div class="game-container" id="game"></div> â¤ï¸ ä½“åŠ›: <div class="bar-container"><div id="hp-bar" class="bar hp"></div></div> ğŸ— æº€è…¹åº¦: <div class="bar-container"><div id="hunger-bar" class="bar hunger"></div></div>
<p style="display:none;">â¤ï¸ ä½“åŠ›: <span id="hp">*</span> / <span id="maxhp">*</span>ã€€ğŸ— æº€è…¹åº¦: <span id="hunger">*</span> / <span id="maxhunger">*</span></p>
<p>ğŸ”ª æ”»æ’ƒåŠ›: <span id="atk">*</span>ã€€ğŸ“ Lv: <span id="lv">1</span>ã€€âœ¨ EXP: <span id="exp">0</span></p>
<p>â›°ï¸ ãƒ•ãƒ­ã‚¢: <span id="floor">1</span>ã€€ğŸ’ ã‚¹ã‚³ã‚¢: <span id="score">0</span></p>
<p>ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
<p>çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ï¼æ•µã¨éš£æ¥ã—ã¦ãŸã‚‰æ”»æ’ƒï¼ï¼.ã§ä¼‘æ†©ï¼ˆ<span id="restCycle"></span>ã‚¿ãƒ¼ãƒ³ã”ã¨ã«å›å¾©ï¼‰ã€€ğŸ”¼:æ¬¡ã®ãƒ•ãƒ­ã‚¢ã¸</p>
<p>ğŸ˜Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€€ğŸ‘¾æ•µã€€ğŸ£ä½“åŠ›å›å¾©ã€€ğŸ’ãŠå®ï¼ã€€ğŸå¤§ããªãƒ‘ãƒ³ï¼ˆ+50ï¼‰ã€€ğŸ¥–ãƒ‘ãƒ³ï¼ˆ+20ï¼‰</p>
<script>

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function randomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}
// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹ 
class Player {
	constructor(x, y, initialHP) {
		this.x = x;
		this.y = y;
		this.hp = initialHP;
		this.maxHp = initialHP;
		this.attack = 2;
		this.healAmount = 3;
		this.level = 1;
		this.exp = 0;
		this.hunger = 100;
		this.maxHunger = 100;
	}
}
// æ•µã‚¯ãƒ©ã‚¹ 
class Enemy {
	constructor(x, y, hp) {
		this.x = x;
		this.y = y;
		this.hp = hp;
	}
	takeDamage(damage) {
		this.hp -= damage;
	}
}
// ãƒãƒƒãƒ—ï¼ˆãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼‰ã‚¯ãƒ©ã‚¹ 
class DungeonMap {
	constructor(width, height) {
			this.width = width;
			this.height = height;
			this.grid = [];
			this.visible = [];
			this.rooms = [];
			this.reset();
		}
		// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ– 
	reset() {
			this.grid = Array.from({
				length: this.height
			}, () => Array(this.width).fill('ğŸŒ³'));
			this.visible = Array.from({
				length: this.height
			}, () => Array(this.width).fill(false));
			this.rooms = [];
		}
		// éƒ¨å±‹ã‚’ä½œæˆã™ã‚‹ 
	createRoom() {
			let w = randomInt(5, 10);
			let h = randomInt(4, 8);
			let x = randomInt(1, this.width - w - 1);
			let y = randomInt(1, this.height - h - 1);
			for (let i = y; i < y + h; i++) {
				for (let j = x; j < x + w; j++) {
					this.grid[i][j] = ' ';
					// ç©ºç™½ã‚¿ã‚¤ãƒ« 
				}
			}
			this.rooms.push({
				x, y, w, h
			});
		}
		// 2ã¤ã®éƒ¨å±‹ã‚’é€šè·¯ã§ã¤ãªã 
	connectRooms(r1, r2) {
			let x1 = r1.x + Math.floor(r1.w / 2);
			let y1 = r1.y + Math.floor(r1.h / 2);
			let x2 = r2.x + Math.floor(r2.w / 2);
			let y2 = r2.y + Math.floor(r2.h / 2);
			while (x1 !== x2) {
				if (this.grid[y1][x1] === 'ğŸŒ³') this.grid[y1][x1] = ' ';
				x1 += (x2 > x1) ? 1 : -1;
			}
			while (y1 !== y2) {
				if (this.grid[y1][x1] === 'ğŸŒ³') this.grid[y1][x1] = ' ';
				y1 += (y2 > y1) ? 1 : -1;
			}
		}
		// ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³å…¨ä½“ã‚’ç”Ÿæˆã™ã‚‹ 
	generate() {
			this.reset();
			const roomCount = randomInt(3, 6);
			for (let i = 0; i < roomCount; i++) {
				this.createRoom();
			}
			for (let i = 0; i < this.rooms.length - 1; i++) {
				this.connectRooms(this.rooms[i], this.rooms[i + 1]);
			}
		}
		// æŒ‡å®šä½ç½®ãŒå«ã¾ã‚Œã‚‹éƒ¨å±‹ã‚’æ˜ã‹ã™ 
	revealRoom(px, py) {
			for (let room of this.rooms) {
				if (px >= room.x && px < room.x + room.w && py >= room.y && py < room.y +
					room.h) {
					for (let i = room.y; i < room.y + room.h; i++) {
						for (let j = room.x; j < room.x + room.w; j++) {
							this.visible[i][j] = true;
							const dirs = [
								[0, -1],
								[0, 1],
								[-1, 0],
								[1, 0]
							];
							for (let [dx, dy] of dirs) {
								let nx = j + dx,
									ny = i + dy;
								if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && this.grid[
										ny][nx] === ' ') {
									this.visible[ny][nx] = true;
								}
							}
						}
					}
					return;
				}
			}
		}
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨å›²ã‚’æ˜ã‹ã™ 
	revealAround(x, y) {
		if (this.grid[y][x] === ' ') {
			for (let dy = -1; dy <= 1; dy++) {
				for (let dx = -1; dx <= 1; dx++) {
					let nx = x + dx,
						ny = y + dy;
					if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
						this.visible[ny][nx] = true;
					}
				}
			}
		}
	}
}
// ã‚²ãƒ¼ãƒ å…¨ä½“ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹ 
class Game {
	constructor() {
			// å®šæ•°ã‚„åˆæœŸçŠ¶æ…‹ 
			this.width = 40;
			this.height = 32;
			this.initialHP = 8;
			this.floor = 1;
			this.score = 0;
			this.isGameOver = false;
			this.generateEnemyCycle = [0, 30];
			this.restCycle = [0, 5];
			this.hungerCycle = [0, 5];
			this.timeoutQueue = [];
			this.acceptingInput = true;
			// å„ç¨®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®é…åˆ— 
			this.enemies = [];
			this.items = [];
			this.gems = [];
			this.foods = [];
			this.stairs = {
				x: 0,
				y: 0
			};
			// ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ 
			this.player = new Player(0, 0, this.initialHP);
			this.map = new DungeonMap(this.width, this.height);
			// DOMè¦ç´ ã®å‚ç…§ 
			this.gameContainer = document.getElementById("game");
			this.hpBar = document.getElementById("hp-bar");
			this.hungerBar = document.getElementById("hunger-bar");
			document.getElementById("restCycle").innerText = this.restCycle[1];
			// åˆå›ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ç”Ÿæˆã¨æç”» 
			this.generateDungeon(false);
			this.render();
			// ã‚­ãƒ¼å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™»éŒ² 
			document.addEventListener('keydown', (e) => this.handleKeyDown(e));
		}
		// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ã‚­ãƒ¥ãƒ¼ç®¡ç† 
	queueTimeout(callback, delay) {
			this.acceptingInput = false;
			const id = setTimeout(() => {
				callback();
				this.timeoutQueue = this.timeoutQueue.filter(t => t !== id);
				if (this.timeoutQueue.length === 0) this.acceptingInput = true;
				this.render();
			}, delay);
			this.timeoutQueue.push(id);
		}
		// ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼ˆãƒãƒƒãƒ—ï¼‰ç”Ÿæˆã€‚keepHPãŒtrueãªã‚‰HPã‚„ã‚¹ã‚³ã‚¢ã‚’å¼•ãç¶™ã 
	generateDungeon(keepHP = false) {
			const prevHP = this.player.hp;
			const prevScore = this.score;
			this.map.generate();
			this.enemies = [];
			this.items = [];
			this.gems = [];
			this.foods = [];
			// æœ€åˆã®éƒ¨å±‹ã®åº§æ¨™ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é…ç½®ã—ã€å‘¨å›²ã‚’æ˜ã‹ã™ 
			const firstRoom = this.map.rooms[0];
			this.player.x = firstRoom.x + 1;
			this.player.y = firstRoom.y + 1;
			this.map.revealRoom(this.player.x, this.player.y);
			this.map.revealAround(this.player.x, this.player.y);
			if (!keepHP) {
				this.player.hp = this.initialHP;
				this.score = 0;
				this.floor = 1;
				this.player.hunger = this.player.maxHunger;
			} else {
				this.player.hp = prevHP;
				this.score = prevScore;
				this.floor++;
			}
			// æœ€å¾Œã®éƒ¨å±‹ã«éšæ®µã‚’é…ç½® 
			const lastRoom = this.map.rooms.at(-1);
			this.stairs.x = lastRoom.x + 2;
			this.stairs.y = lastRoom.y + 2;
			this.map.grid[this.stairs.y][this.stairs.x] = 'ğŸ”¼';
			// æ•µã®HPã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ç”¨ã®å€ç‡ 
			this.minMagnification = 1.1;
			this.maxMagnification = 1.4;
			// å„ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’é…ç½® 
			this.placeEntities(this.enemies, randomInt(2, 4), "enemy");
			this.placeEntities(this.items, randomInt(0, 2), "entity");
			this.placeEntities(this.gems, randomInt(1, 3), "entity");
			this.placeEntities(this.foods, randomInt(1, 2), "food");
		}
		// ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆæ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ ãƒ»é£Ÿæ–™ãªã©ï¼‰ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ã™ã‚‹ 
	placeEntities(arr, count, type) {
			for (let i = 0; i < count; i++) {
				let x, y, hp;
				do {
					const room = this.map.rooms[randomInt(0, this.map.rooms.length - 1)];
					x = randomInt(room.x + 1, room.x + room.w - 2);
					y = randomInt(room.y + 1, room.y + room.h - 2);
					if (type === "enemy") {
						hp = randomInt(Math.round(Math.pow(this.floor, this.minMagnification)),
							Math.round(Math.pow(this.floor, this.maxMagnification)));
					}
				} while (this.map.grid[y][x] !== ' ' || (x === this.player.x && y === this.player
						.y));
				if (type === "entity") {
					arr.push({
						x, y
					});
				} else if (type === "enemy") {
					arr.push(new Enemy(x, y, hp));
				} else if (type === "food") {
					const kind = Math.random() < 0.7 ? "small" : "big";
					arr.push({
						x, y, kind
					});
				}
			}
		}
		// UIã®ãƒãƒ¼ã‚’æ›´æ–° 
	updateBars() {
			this.hpBar.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`;
			this.hpBar.textContent = `${this.player.hp}/${this.player.maxHp}`;
			this.hungerBar.style.width =
				`${(this.player.hunger / this.player.maxHunger) * 100}%`;
			this.hungerBar.textContent =
				`${this.player.hunger}/${this.player.maxHunger}`;
			if (this.player.hp > this.player.maxHp / 2) {
				this.hpBar.style.backgroundColor = "green";
			} else if (this.player.hp > this.player.maxHp / 4) {
				this.hpBar.style.backgroundColor = "orange";
			} else {
				this.hpBar.style.backgroundColor = "red";
			}
		}
		// çµŒé¨“å€¤ã‚’ç²å¾—ã—ã€ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’è¡Œã† 
	gainExp(amount) {
			this.player.exp += amount;
			const expToNext = this.player.level * 10;
			if (this.player.exp >= expToNext) {
				this.player.exp -= expToNext;
				this.player.level++;
				this.player.attack++;
				this.player.maxHp++;
				this.player.healAmount++;
				this.player.hp = this.player.maxHp;
				this.showEffect(this.player.x, this.player.y, "LEVEL UP!", "heal");
			}
		}
		// é£Ÿäº‹å‡¦ç† 
	playerEat(amount) {
			this.player.hunger += amount;
			if (this.player.hunger > this.player.maxHunger) this.player.hunger = this.player
				.maxHunger;
			this.showEffect(this.player.x, this.player.y, `+${amount}`, "food");
		}
		// æº€è…¹åº¦ï¼ˆãƒãƒ³ã‚¬ãƒ¼ï¼‰ãƒã‚§ãƒƒã‚¯ 
	checkHunger() {
			this.hungerCycle[0] = (this.hungerCycle[0] + 1) % this.hungerCycle[1];
			if (this.hungerCycle[0] === 0) {
				this.player.hunger--;
				if (this.player.hunger < 0) this.player.hunger = 0;
			}
			if (this.player.hunger === 0) {
				this.player.hp--;
				this.showEffect(this.player.x, this.player.y, "é¤“æ­»", "damage");
			}
		}
		// æ•µã®ç§»å‹•å‡¦ç† 
	moveEnemies(nextPlayerX, nextPlayerY) {
			this.enemies.forEach((enemy, idx) => {
				if (enemy.hp <= 0) return;
				const dx = Math.abs(enemy.x - this.player.x);
				const dy = Math.abs(enemy.y - this.player.y);
				this.queueTimeout(() => {
					if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
						this.player.hp--;
						this.showEffect(this.player.x, this.player.y, "-1", "damage-me");
						return;
					}
				}, 100);
				const dirX = Math.sign(this.player.x - enemy.x);
				const dirY = Math.sign(this.player.y - enemy.y);
				const nx = enemy.x + dirX,
					ny = enemy.y + dirY;
				const canMoveX = this.map.grid[enemy.y][nx] !== 'ğŸŒ³' && !this.enemies.some(
					e => e.x === nx && e.y === enemy.y) && !(nx === this.player.x && enemy.y ===
					this.player.y) && !(nx === nextPlayerX && enemy.y === nextPlayerY);
				const canMoveY = this.map.grid[ny] ? .[enemy.x] !== 'ğŸŒ³' && !this.enemies
					.some(e => e.x === enemy.x && e.y === ny) && !(enemy.x === this.player.x &&
						ny === this.player.y) && !(enemy.x === nextPlayerX && ny ===
						nextPlayerY);
				if (canMoveX && canMoveY) {
					Math.random() < 0.5 ? enemy.x += dirX : enemy.y += dirY;
				} else if (canMoveX) {
					enemy.x += dirX;
				} else if (canMoveY) {
					enemy.y += dirY;
				}
			});
		}
		// æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã€HPãŒ0ä»¥ä¸‹ãªã‚‰å€’ã™ 
	damageEnemy(enemy, index) {
			enemy.takeDamage(this.player.attack);
			this.showEffect(enemy.x, enemy.y, `-${this.player.attack}`, "damage");
			if (enemy.hp <= 0) {
				this.showEffect(enemy.x, enemy.y, "ğŸ’¥", "explosion");
				this.enemies.splice(index, 1);
				this.score += 50;
				this.gainExp(5);
			}
		}
		// å„ç¨®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¨ã®è¡çªåˆ¤å®š 
	checkCollisions() {
			this.items = this.items.filter(item => {
				if (item.x === this.player.x && item.y === this.player.y) {
					this.onHeal();
					return false;
				}
				return true;
			});
			this.gems = this.gems.filter(gem => {
				if (gem.x === this.player.x && gem.y === this.player.y) {
					this.score += 100;
					return false;
				}
				return true;
			});
			this.foods = this.foods.filter(food => {
				if (food.x === this.player.x && food.y === this.player.y) {
					const amount = food.kind === "big" ? 50 : 20;
					this.playerEat(amount);
					return false;
				}
				return true;
			});
			setTimeout(() => {
				if (this.player.hp <= 0) {
					this.isGameOver = true;
					this.timeoutQueue.forEach(id => clearTimeout(id));
					this.timeoutQueue = [];
					this.acceptingInput = true;
					this.restCycle[0] = 0;
					this.generateEnemyCycle[0] = 0;
					this.hungerCycle[0] = 0;
					alert("å€’ã‚Œã¦ã—ã¾ã£ãŸï¼");
					this.generateDungeon(false);
					this.isGameOver = false;
					this.render();
				}
			}, 100);
		}
		// ç”»é¢ä¸Šã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆæµ®éŠãƒ†ã‚­ã‚¹ãƒˆï¼‰ã‚’è¡¨ç¤ºã™ã‚‹ 
	showEffect(x, y, text, type = "damage") {
			const spans = this.gameContainer.children;
			const index = y * (this.width + 1) + x;
			if (!spans[index]) return;
			const target = spans[index];
			const rect = target.getBoundingClientRect();
			const fx = document.createElement("div");
			fx.className = type;
			fx.textContent = text;
			if (type === "explosion") {
				fx.style.left = `${rect.left + rect.width / 2 + window.scrollX}px`;
				fx.style.top = `${rect.top + window.scrollY - rect.height * 0.6 + 30}px`;
			} else {
				fx.style.left =
					`${rect.left + rect.width / 2 + window.scrollX + randomInt(-30, 30)}px`;
				fx.style.top = `${rect.top + window.scrollY - rect.height * 0.6}px`;
			}
			document.body.appendChild(fx);
			setTimeout(() => fx.remove(), 1000);
		}
		// å›å¾©å‡¦ç†ï¼ˆã‚¢ã‚¤ãƒ†ãƒ å–å¾—æ™‚ãªã©ï¼‰ 
	onHeal() {
			this.player.hp += this.player.healAmount;
			if (this.player.hp > this.player.maxHp) this.player.hp = this.player.maxHp;
			this.showEffect(this.player.x, this.player.y, `+${this.player.healAmount}`,
				"heal");
		}
		// ã‚­ãƒ¼å…¥åŠ›å‡¦ç†ï¼ˆç§»å‹•ã€æ”»æ’ƒã€ä¼‘æ†©ãªã©ï¼‰ 
	handleKeyDown(event) {
			if (this.isGameOver || !this.acceptingInput) return;
			let dx = 0,
				dy = 0;
			if (event.key === 'ArrowUp') dy = -1;
			else if (event.key === 'ArrowDown') dy = 1;
			else if (event.key === 'ArrowLeft') dx = -1;
			else if (event.key === 'ArrowRight') dx = 1;
			else if (event.key === '.') {
				this.restCycle[0] = (this.restCycle[0] + 1) % this.restCycle[1];
				if (this.restCycle[0] === 0 && this.player.hp < this.player.maxHp) {
					this.player.hp++;
				}
			} else return;
			this.generateEnemyCycle[0] = (this.generateEnemyCycle[0] + 1) % this.generateEnemyCycle[
				1];
			const tx = this.player.x + dx;
			const ty = this.player.y + dy;
			let attacked = false;
			// æ•µã¨ã®è¡çªåˆ¤å®šï¼ˆæ”»æ’ƒå‡¦ç†ï¼‰ 
			for (let i = 0; i < this.enemies.length; i++) {
				if (this.enemies[i].x === tx && this.enemies[i].y === ty) {
					attacked = true;
					this.queueTimeout(() => {
						this.damageEnemy(this.enemies[i], i);
					}, 50);
					break;
				}
			}
			if (!attacked && this.map.grid[ty] ? .[tx] !== 'ğŸŒ³' && !this.enemies.some(e =>
					e.x === tx && e.y === ty)) {
				this.player.x = tx;
				this.player.y = ty;
				this.map.visible[ty][tx] = true;
				this.map.revealRoom(tx, ty);
				this.map.revealAround(tx, ty);
			}
			if (this.player.x === this.stairs.x && this.player.y === this.stairs.y) {
				this.generateDungeon(true);
				return;
			}
			this.checkHunger();
			this.moveEnemies(tx, ty);
			this.checkCollisions();
			if (this.generateEnemyCycle[0] === 0) {
				this.placeEntities(this.enemies, randomInt(1, 3), "enemy");
			}
			this.render();
		}
		// ã‚²ãƒ¼ãƒ ç”»é¢ã®å†æç”» 
	render() {
		let html = '';
		for (let y = 0; y < this.height; y++) {
			for (let x = 0; x < this.width; x++) {
				if (!this.map.visible[y][x]) {
					html += `<span class="wall">ğŸŒ³</span>`;
					continue;
				}
				let classList = '';
				let tile = this.map.grid[y][x];
				if (this.player.x === x && this.player.y === y) {
					tile = 'ğŸ˜Š';
				} else {
					let drawn = false;
					// é£Ÿæ–™ã‚’æç”» 
					for (let food of this.foods) {
						if (food.x === x && food.y === y) {
							tile = food.kind === "big" ? "ğŸ" : "ğŸ¥–";
							drawn = true;
							break;
						}
					}
					// æ•µã‚’æç”» 
					if (!drawn) {
						for (let enemy of this.enemies) {
							if (enemy.x === x && enemy.y === y) {
								tile = 'ğŸ‘¾';
								drawn = true;
								break;
							}
						}
					}
					// ã‚¢ã‚¤ãƒ†ãƒ ãƒ»ãŠå®ã‚’æç”» 
					if (!drawn) {
						for (let item of this.items) {
							if (item.x === x && item.y === y) {
								tile = 'ğŸ£';
								drawn = true;
								break;
							}
						}
						for (let gem of this.gems) {
							if (gem.x === x && gem.y === y) {
								tile = 'ğŸ’';
								drawn = true;
								break;
							}
						}
						if (this.stairs.x === x && this.stairs.y === y) tile = 'ğŸ”¼';
					}
				}
				html += `<span class="${classList}">${tile}</span>`;
			}
			html += '<br>';
		}
		this.gameContainer.innerHTML = html;
		// UIæƒ…å ±ã®æ›´æ–° 
		document.getElementById('hp').innerText = this.player.hp;
		document.getElementById('maxhp').innerText = this.player.maxHp;
		document.getElementById('atk').innerText = this.player.attack;
		document.getElementById('lv').innerText = this.player.level;
		document.getElementById('exp').innerText = this.player.exp;
		document.getElementById('floor').innerText = this.floor;
		document.getElementById('score').innerText = this.score;
		document.getElementById('hunger').innerText = this.player.hunger;
		document.getElementById('maxhunger').innerText = this.player.maxHunger;
		this.updateBars();
	}
}
// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã—ã¦ã‚²ãƒ¼ãƒ é–‹å§‹ 
new Game();
</script>
</body>
</html> 
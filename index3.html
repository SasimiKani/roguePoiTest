<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ãƒ­ãƒ¼ã‚°ã£ã½ã„ä½•ã‹ï¼ˆå†…éƒ¨å‡¦ç†åˆ†é›¢ãƒ»æ”¹å–„ç‰ˆï¼‰</title>
  <style>
    /* ã‚¹ã‚¿ã‚¤ãƒ«ã¯å…ƒã®ã‚³ãƒ¼ãƒ‰ã¨åŒç­‰ */
    body { font-family: monospace; position: relative; }
    .game-container { font-size: 16px; line-height: 1.2; white-space: pre; position: relative; }
    .game-container span { display: inline-block; width: 2.2ch; text-align: center; transition: all 0.1s; }
    .wall { background-color: #C4DD87; display: inline-block; height: 20px; }
    .hit { background-color: red !important; color: white; }
    .shake { transform: translateY(-2px); }
    .damage, .damage-me, .heal, .explosion, .food {
      position: absolute; font-weight: bold; font-size: 18px; border-radius: 4px;
      pointer-events: none; transform: translate(-50%, -100%);
      animation: floatUp 1.0s ease-out forwards;
    }
    .damage-me { color: white; background-color: red; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .damage { color: white; background-color: orange; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .heal { color: white; background-color: green; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .food { color: white; background-color: green; padding: 2px 4px; box-shadow: 1px 1px 2px black; }
    .explosion { color: orange; font-size: 22px; animation: explodeUp 0.4s ease-out forwards; }
    @keyframes floatUp { 0% { opacity: 1; transform: translate(-50%, -100%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -160%) scale(1.3); } }
    @keyframes explodeUp { 0% { opacity: 1; transform: translate(-50%, -100%) scale(0.8); } 100% { opacity: 0; transform: translate(-50%, -180%) scale(1.6); } }
    .bar-container { width: 200px; height: 16px; background-color: #ccc; border: 1px solid #999; border-radius: 20px; margin-bottom: 2px; position: relative; }
    .bar { height: 100%; border-radius: 20px; text-align: center; color: white; font-size: 12px; line-height: 16px; }
    .bar.hp { background-color: green; }
    .bar.hunger { background-color: skyblue; }
    p { font-size: 16px; line-height: 0.6; }
  </style>
</head>
<body>
  <div class="game-container" id="game"></div>
  â¤ï¸ ä½“åŠ›: <div class="bar-container"><div id="hp-bar" class="bar hp"></div></div>
  ğŸ— æº€è…¹åº¦: <div class="bar-container"><div id="hunger-bar" class="bar hunger"></div></div>
  <p style="display:none;">â¤ï¸ ä½“åŠ›: <span id="hp">*</span> / <span id="maxhp">*</span>ã€€ğŸ— æº€è…¹åº¦: <span id="hunger">*</span> / <span id="maxhunger">*</span></p>
  <p>ğŸ”ª æ”»æ’ƒåŠ›: <span id="atk">*</span>ã€€ğŸ“ Lv: <span id="lv">1</span>ã€€âœ¨ EXP: <span id="exp">0</span></p>
  <p>â›°ï¸ ãƒ•ãƒ­ã‚¢: <span id="floor">1</span>ã€€ğŸ’ ã‚¹ã‚³ã‚¢: <span id="score">0</span></p>
  <p>ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
  <p>çŸ¢å°ã‚­ãƒ¼ã§ç§»å‹•ï¼æ•µã¨éš£æ¥ã—ã¦ãŸã‚‰æ”»æ’ƒï¼ï¼.ã§ä¼‘æ†©ï¼ˆ<span id="restCycle"></span>ã‚¿ãƒ¼ãƒ³ã”ã¨ã«å›å¾©ï¼‰ã€€ğŸ”¼:æ¬¡ã®ãƒ•ãƒ­ã‚¢ã¸</p>
  <p>ğŸ˜Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€€ğŸ‘¾æ•µã€€ğŸ£ä½“åŠ›å›å¾©ã€€ğŸ’ãŠå®ï¼ã€€ğŸå¤§ããªãƒ‘ãƒ³ï¼ˆ+50ï¼‰ã€€ğŸ¥–ãƒ‘ãƒ³ï¼ˆ+20ï¼‰</p>
  
  <script>
    // ---------------- Configuration ----------------
    const CONFIG = {
      WIDTH: 40,
      HEIGHT: 32,
      INITIAL_HP: 8,
      REST_CYCLE: 5,
      GENERATE_ENEMY_CYCLE: 30,
      HUNGER_CYCLE: 5,
      MIN_ENEMY_MULTIPLIER: 1.1,
      MAX_ENEMY_MULTIPLIER: 1.4,
    };

    // ---------------- Helper Functions ----------------
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // ---------------- Base Entity Class ----------------
    class BaseEntity {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    }

    // ---------------- Player Class ----------------
    class Player extends BaseEntity {
      constructor(x, y, initialHP) {
        super(x, y);
        this.hp = initialHP;
        this.maxHp = initialHP;
        this.attack = 2;
        this.healAmount = 3;
        this.level = 1;
        this.exp = 0;
        this.hunger = 100;
        this.maxHunger = 100;
      }
    }

    // ---------------- Enemy Class ----------------
    class Enemy extends BaseEntity {
      constructor(x, y, hp) {
        super(x, y);
        this.hp = hp;
      }
      takeDamage(damage) {
        this.hp -= damage;
      }
    }

    // ---------------- Food Class ----------------
    class Food extends BaseEntity {
      constructor(x, y, kind) {
        super(x, y);
        this.kind = kind; // "small" or "big"
      }
    }

    // ---------------- DungeonMap Class ----------------
    class DungeonMap {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        this.grid = [];
        this.visible = [];
        this.rooms = [];
        this.reset();
      }
      reset() {
        this.grid = Array.from({ length: this.height }, () => Array(this.width).fill('ğŸŒ³'));
        this.visible = Array.from({ length: this.height }, () => Array(this.width).fill(false));
        this.rooms = [];
      }
      createRoom() {
        let w = randomInt(5, 10);
        let h = randomInt(4, 8);
        let x = randomInt(1, this.width - w - 1);
        let y = randomInt(1, this.height - h - 1);
        for (let i = y; i < y + h; i++) {
          for (let j = x; j < x + w; j++) {
            this.grid[i][j] = ' '; // ç©ºç™½ã‚¿ã‚¤ãƒ«
          }
        }
        this.rooms.push({ x, y, w, h });
      }
      connectRooms(r1, r2) {
        let x1 = r1.x + Math.floor(r1.w / 2);
        let y1 = r1.y + Math.floor(r1.h / 2);
        let x2 = r2.x + Math.floor(r2.w / 2);
        let y2 = r2.y + Math.floor(r2.h / 2);
        while (x1 !== x2) {
          if (this.grid[y1][x1] === 'ğŸŒ³') this.grid[y1][x1] = ' ';
          x1 += (x2 > x1) ? 1 : -1;
        }
        while (y1 !== y2) {
          if (this.grid[y1][x1] === 'ğŸŒ³') this.grid[y1][x1] = ' ';
          y1 += (y2 > y1) ? 1 : -1;
        }
      }
      generate() {
        this.reset();
        const roomCount = randomInt(3, 6);
        for (let i = 0; i < roomCount; i++) {
          this.createRoom();
        }
        for (let i = 0; i < this.rooms.length - 1; i++) {
          this.connectRooms(this.rooms[i], this.rooms[i + 1]);
        }
      }
      revealRoom(px, py) {
        for (let room of this.rooms) {
          if (px >= room.x && px < room.x + room.w && py >= room.y && py < room.y + room.h) {
            for (let i = room.y; i < room.y + room.h; i++) {
              for (let j = room.x; j < room.x + room.w; j++) {
                this.visible[i][j] = true;
                const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                for (let [dx, dy] of dirs) {
                  let nx = j + dx, ny = i + dy;
                  if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height &&
                      this.grid[ny][nx] === ' ') {
                    this.visible[ny][nx] = true;
                  }
                }
              }
            }
            return;
          }
        }
      }
      revealAround(x, y) {
        if (this.grid[y][x] === ' ') {
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              let nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                this.visible[ny][nx] = true;
              }
            }
          }
        }
      }
    }

    // ---------------- UIManager Class ----------------
    class UIManager {
      constructor() {
        this.hpBar = document.getElementById("hp-bar");
        this.hungerBar = document.getElementById("hunger-bar");
      }
      update(player) {
        this.hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        this.hpBar.textContent = `${player.hp}/${player.maxHp}`;
        this.hungerBar.style.width = `${(player.hunger / player.maxHunger) * 100}%`;
        this.hungerBar.textContent = `${player.hunger}/${player.maxHunger}`;
        if (player.hp > player.maxHp / 2) {
          this.hpBar.style.backgroundColor = "green";
        } else if (player.hp > player.maxHp / 4) {
          this.hpBar.style.backgroundColor = "orange";
        } else {
          this.hpBar.style.backgroundColor = "red";
        }
      }
    }

    // ---------------- EffectsManager Class ----------------
    class EffectsManager {
      static showEffect(container, x, y, text, type = "damage") {
        const spans = container.children;
        const index = y * (CONFIG.WIDTH + 1) + x;
        if (!spans[index]) return;
        const target = spans[index];
        const rect = target.getBoundingClientRect();
        const fx = document.createElement("div");
        fx.className = type;
        fx.textContent = text;
        if (type === "explosion") {
          fx.style.left = `${rect.left + rect.width / 2 + window.scrollX}px`;
          fx.style.top = `${rect.top + window.scrollY - rect.height * 0.6 + 30}px`;
        } else {
          fx.style.left = `${rect.left + rect.width / 2 + window.scrollX + randomInt(-30, 30)}px`;
          fx.style.top = `${rect.top + window.scrollY - rect.height * 0.6}px`;
        }
        document.body.appendChild(fx);
        setTimeout(() => fx.remove(), 1000);
      }
    }

    // ---------------- InputManager Class ----------------
    class InputManager {
      constructor(game) {
        this.game = game;
        this.init();
      }
      init() {
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
      }
      handleKeyDown(event) {
        this.game.processInput(event);
      }
    }

    // ---------------- Game Class ----------------
    class Game {
      constructor() {
        this.width = CONFIG.WIDTH;
        this.height = CONFIG.HEIGHT;
        this.initialHP = CONFIG.INITIAL_HP;
        this.floor = 1;
        this.score = 0;
        this.isGameOver = false;
        this.generateEnemyCycle = [0, CONFIG.GENERATE_ENEMY_CYCLE];
        this.restCycle = [0, CONFIG.REST_CYCLE];
        this.hungerCycle = [0, CONFIG.HUNGER_CYCLE];
        this.timeoutQueue = [];
        this.acceptingInput = true;
        this.enemies = [];
        this.items = [];
        this.gems = [];
        this.foods = [];
        this.stairs = { x: 0, y: 0 };
        this.player = new Player(0, 0, this.initialHP);
        this.map = new DungeonMap(this.width, this.height);
        this.uiManager = new UIManager();
        this.gameContainer = document.getElementById("game");
        document.getElementById("restCycle").innerText = CONFIG.REST_CYCLE;
        this.generateDungeon(false);
        this.render();
        new InputManager(this);
      }

      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®ã‚­ãƒ¥ãƒ¼ç®¡ç†
      queueTimeout(callback, delay) {
        this.acceptingInput = false;
        const id = setTimeout(() => {
          callback();
          this.timeoutQueue = this.timeoutQueue.filter(t => t !== id);
          if (this.timeoutQueue.length === 0) this.acceptingInput = true;
          this.render();
        }, delay);
        this.timeoutQueue.push(id);
      }

      // ---------------- å†…éƒ¨å‡¦ç†ï¼šæ¼”ç®—å‡¦ç† ----------------
      // å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ã€Œç§»å‹•å…ˆã€ã‚„ã€Œæ”»æ’ƒå¯¾è±¡ã€ãªã©ã‚’è¨ˆç®—ã™ã‚‹
      computeInput(event) {
        let dx = 0, dy = 0;
        if (event.key === 'ArrowUp') dy = -1;
        else if (event.key === 'ArrowDown') dy = 1;
        else if (event.key === 'ArrowLeft') dx = -1;
        else if (event.key === 'ArrowRight') dx = 1;
        else if (event.key === '.') {
          // ä¼‘æ†©æ™‚ã¯ä½“åŠ›å›å¾©ã®è¨ˆç®—ã®ã¿è¡Œã„ã€ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹ãŸã‚åŒã˜ä½ç½®ã‚’è¿”ã™
          this.restCycle[0] = (this.restCycle[0] + 1) % this.restCycle[1];
          if (this.restCycle[0] === 0 && this.player.hp < this.player.maxHp) {
            this.player.hp++;
          }
          // ä¼‘æ†©ã§ã‚‚ã‚¿ãƒ¼ãƒ³é€²è¡Œã¨å„å‡¦ç†ãŒè¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«åŒã˜ä½ç½®ã‚’è¿”ã™
          return { tx: this.player.x, ty: this.player.y };
        } else return null;
        return { tx: this.player.x + dx, ty: this.player.y + dy };
      }

      // ---------------- å†…éƒ¨å‡¦ç†ï¼šãƒ‡ãƒ¼ã‚¿æ›´æ–°å‡¦ç† ----------------
      // è¨ˆç®—çµæœã«åŸºã¥ã„ã¦ã‚²ãƒ¼ãƒ å†…ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã™ã‚‹
      updateData(inputResult) {
        if (!inputResult) return;
        const { tx, ty } = inputResult;
        let attacked = false;
        // æ”»æ’ƒåˆ¤å®šï¼šæŒ‡å®šåº§æ¨™ã«æ•µãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        for (let i = 0; i < this.enemies.length; i++) {
          if (this.enemies[i].x === tx && this.enemies[i].y === ty) {
            attacked = true;
            this.queueTimeout(() => {
              this.damageEnemy(this.enemies[i], i);
            }, 50);
            break;
          }
        }
        // æ•µãŒã„ãªã‘ã‚Œã°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•
        if (!attacked && this.map.grid[ty]?.[tx] !== 'ğŸŒ³' &&
            !this.enemies.some(e => e.x === tx && e.y === ty)) {
          this.player.x = tx;
          this.player.y = ty;
          this.map.visible[ty][tx] = true;
          this.map.revealRoom(tx, ty);
          this.map.revealAround(tx, ty);
        }
        // éšæ®µã«åˆ°é”ã—ãŸå ´åˆã¯ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ç”Ÿæˆ
        if (this.player.x === this.stairs.x && this.player.y === this.stairs.y) {
          this.generateDungeon(true);
          return;
        }
        // ãã®ä»–ã®æ›´æ–°å‡¦ç†
        this.checkHunger();
        this.moveEnemies(tx, ty);
        this.checkCollisions();
        if (this.generateEnemyCycle[0] === 0) {
          this.placeEntities(this.enemies, randomInt(1, 3), "enemy");
        }
      }

      // ---------------- å†…éƒ¨å‡¦ç†ï¼šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç† ----------------
      // ç¾åœ¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ç”»é¢ã«åæ˜ ã™ã‚‹
      render() {
        let html = '';
        for (let y = 0; y < this.height; y++) {
          for (let x = 0; x < this.width; x++) {
            if (!this.map.visible[y][x]) {
              html += `<span class="wall">ğŸŒ³</span>`;
              continue;
            }
            let tile = this.map.grid[y][x];
            if (this.player.x === x && this.player.y === y) {
              tile = 'ğŸ˜Š';
            } else {
              let drawn = false;
              // é£Ÿæ–™è¡¨ç¤º
              for (let food of this.foods) {
                if (food.x === x && food.y === y) {
                  tile = food.kind === "big" ? "ğŸ" : "ğŸ¥–";
                  drawn = true;
                  break;
                }
              }
              // æ•µè¡¨ç¤º
              if (!drawn) {
                for (let enemy of this.enemies) {
                  if (enemy.x === x && enemy.y === y) {
                    tile = 'ğŸ‘¾';
                    drawn = true;
                    break;
                  }
                }
              }
              // ã‚¢ã‚¤ãƒ†ãƒ ãƒ»å®çŸ³è¡¨ç¤º
              if (!drawn) {
                for (let item of this.items) {
                  if (item.x === x && item.y === y) {
                    tile = 'ğŸ£';
                    drawn = true;
                    break;
                  }
                }
                for (let gem of this.gems) {
                  if (gem.x === x && gem.y === y) {
                    tile = 'ğŸ’';
                    drawn = true;
                    break;
                  }
                }
                if (this.stairs.x === x && this.stairs.y === y) tile = 'ğŸ”¼';
              }
            }
            html += `<span>${tile}</span>`;
          }
          html += '<br>';
        }
        this.gameContainer.innerHTML = html;
        // UIæƒ…å ±æ›´æ–°
        document.getElementById('hp').innerText = this.player.hp;
        document.getElementById('maxhp').innerText = this.player.maxHp;
        document.getElementById('atk').innerText = this.player.attack;
        document.getElementById('lv').innerText = this.player.level;
        document.getElementById('exp').innerText = this.player.exp;
        document.getElementById('floor').innerText = this.floor;
        document.getElementById('score').innerText = this.score;
        document.getElementById('hunger').innerText = this.player.hunger;
        document.getElementById('maxhunger').innerText = this.player.maxHunger;
        this.uiManager.update(this.player);
      }

      // processInput() ã¯ã€ä»¥ä¸‹ã®3æ®µéšã§å‡¦ç†ã™ã‚‹
      processInput(event) {
        if (this.isGameOver || !this.acceptingInput) return;
        // ã¾ãš generateEnemyCycle ã®æ›´æ–°
        this.generateEnemyCycle[0] = (this.generateEnemyCycle[0] + 1) % this.generateEnemyCycle[1];
        // â‘  æ¼”ç®—å‡¦ç†
        const inputResult = this.computeInput(event);
        // â‘¡ ãƒ‡ãƒ¼ã‚¿æ›´æ–°å‡¦ç†
        this.updateData(inputResult);
        // â‘¢ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‡¦ç†
        this.render();
      }

      // ä»¥é™ã¯å…ƒã®æ©Ÿèƒ½ã‚’ç¶­æŒã™ã‚‹å‡¦ç†ç¾¤

      generateDungeon(keepHP = false) {
        const prevHP = this.player.hp;
        const prevScore = this.score;
        this.map.generate();
        this.enemies = [];
        this.items = [];
        this.gems = [];
        this.foods = [];
        const firstRoom = this.map.rooms[0];
        this.player.x = firstRoom.x + 1;
        this.player.y = firstRoom.y + 1;
        this.map.revealRoom(this.player.x, this.player.y);
        this.map.revealAround(this.player.x, this.player.y);
        if (!keepHP) {
          this.player.hp = this.initialHP;
          this.score = 0;
          this.floor = 1;
          this.player.hunger = this.player.maxHunger;
        } else {
          this.player.hp = prevHP;
          this.score = prevScore;
          this.floor++;
        }
        const lastRoom = this.map.rooms.at(-1);
        this.stairs.x = lastRoom.x + 2;
        this.stairs.y = lastRoom.y + 2;
        this.map.grid[this.stairs.y][this.stairs.x] = 'ğŸ”¼';
        this.minMagnification = CONFIG.MIN_ENEMY_MULTIPLIER;
        this.maxMagnification = CONFIG.MAX_ENEMY_MULTIPLIER;
        this.placeEntities(this.enemies, randomInt(2, 4), "enemy");
        this.placeEntities(this.items, randomInt(0, 2), "entity");
        this.placeEntities(this.gems, randomInt(1, 3), "entity");
        this.placeEntities(this.foods, randomInt(1, 2), "food");
      }

      placeEntities(arr, count, type) {
        for (let i = 0; i < count; i++) {
          let x, y, hp;
          do {
            const room = this.map.rooms[randomInt(0, this.map.rooms.length - 1)];
            x = randomInt(room.x + 1, room.x + room.w - 2);
            y = randomInt(room.y + 1, room.y + room.h - 2);
            if (type === "enemy") {
              hp = randomInt(
                Math.round(Math.pow(this.floor, this.minMagnification)),
                Math.round(Math.pow(this.floor, this.maxMagnification))
              );
            }
          } while (this.map.grid[y][x] !== ' ' || (x === this.player.x && y === this.player.y));
          if (type === "entity") {
            arr.push({ x, y });
          } else if (type === "enemy") {
            arr.push(new Enemy(x, y, hp));
          } else if (type === "food") {
            const kind = Math.random() < 0.7 ? "small" : "big";
            arr.push(new Food(x, y, kind));
          }
        }
      }

      gainExp(amount) {
        this.player.exp += amount;
        const expToNext = this.player.level * 10;
        if (this.player.exp >= expToNext) {
          this.player.exp -= expToNext;
          this.player.level++;
          this.player.attack++;
          this.player.maxHp++;
          this.player.healAmount++;
          this.player.hp = this.player.maxHp;
          EffectsManager.showEffect(this.gameContainer, this.player.x, this.player.y, "LEVEL UP!", "heal");
        }
      }

      playerEat(amount) {
        this.player.hunger += amount;
        if (this.player.hunger > this.player.maxHunger) this.player.hunger = this.player.maxHunger;
        EffectsManager.showEffect(this.gameContainer, this.player.x, this.player.y, `+${amount}`, "food");
      }

      checkHunger() {
        this.hungerCycle[0] = (this.hungerCycle[0] + 1) % this.hungerCycle[1];
        if (this.hungerCycle[0] === 0) {
          this.player.hunger--;
          if (this.player.hunger < 0) this.player.hunger = 0;
        }
        if (this.player.hunger === 0) {
          this.player.hp--;
          EffectsManager.showEffect(this.gameContainer, this.player.x, this.player.y, "é¤“æ­»", "damage");
        }
      }

      moveEnemies(nextPlayerX, nextPlayerY) {
        this.enemies.forEach((enemy, idx) => {
          if (enemy.hp <= 0) return;
          const dx = Math.abs(enemy.x - this.player.x);
          const dy = Math.abs(enemy.y - this.player.y);
          // ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã‚‚ã€æ•µãŒå€’ã‚Œã¦ã„ãªã„ã‹ç¢ºèªã™ã‚‹
          this.queueTimeout(() => {
            if (enemy.hp <= 0) return;
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
              this.player.hp--;
              EffectsManager.showEffect(this.gameContainer, this.player.x, this.player.y, "-1", "damage-me");
              return;
            }
          }, 100);
          const dirX = Math.sign(this.player.x - enemy.x);
          const dirY = Math.sign(this.player.y - enemy.y);
          const nx = enemy.x + dirX, ny = enemy.y + dirY;
          const canMoveX = this.map.grid[enemy.y][nx] !== 'ğŸŒ³' &&
                           !this.enemies.some(e => e.x === nx && e.y === enemy.y) &&
                           !(nx === this.player.x && enemy.y === this.player.y) &&
                           !(nx === nextPlayerX && enemy.y === nextPlayerY);
          const canMoveY = this.map.grid[ny]?.[enemy.x] !== 'ğŸŒ³' &&
                           !this.enemies.some(e => e.x === enemy.x && e.y === ny) &&
                           !(enemy.x === this.player.x && ny === this.player.y) &&
                           !(enemy.x === nextPlayerX && ny === nextPlayerY);
          if (canMoveX && canMoveY) {
            Math.random() < 0.5 ? enemy.x += dirX : enemy.y += dirY;
          } else if (canMoveX) {
            enemy.x += dirX;
          } else if (canMoveY) {
            enemy.y += dirY;
          }
        });
      }

      damageEnemy(enemy, index) {
        enemy.takeDamage(this.player.attack);
        EffectsManager.showEffect(this.gameContainer, enemy.x, enemy.y, `-${this.player.attack}`, "damage");
        if (enemy.hp <= 0) {
          EffectsManager.showEffect(this.gameContainer, enemy.x, enemy.y, "ğŸ’¥", "explosion");
          this.enemies.splice(index, 1);
          this.score += 50;
          this.gainExp(5);
        }
      }

      checkCollisions() {
        this.items = this.items.filter(item => {
          if (item.x === this.player.x && item.y === this.player.y) {
            this.onHeal();
            return false;
          }
          return true;
        });
        this.gems = this.gems.filter(gem => {
          if (gem.x === this.player.x && gem.y === this.player.y) {
            this.score += 100;
            return false;
          }
          return true;
        });
        this.foods = this.foods.filter(food => {
          if (food.x === this.player.x && food.y === this.player.y) {
            const amount = food.kind === "big" ? 50 : 20;
            this.playerEat(amount);
            return false;
          }
          return true;
        });
        setTimeout(() => {
          if (this.player.hp <= 0) {
            this.isGameOver = true;
            this.timeoutQueue.forEach(id => clearTimeout(id));
            this.timeoutQueue = [];
            this.acceptingInput = true;
            this.restCycle[0] = 0;
            this.generateEnemyCycle[0] = 0;
            this.hungerCycle[0] = 0;
            alert("å€’ã‚Œã¦ã—ã¾ã£ãŸï¼");
            this.generateDungeon(false);
            this.isGameOver = false;
            this.render();
          }
        }, 100);
      }

      onHeal() {
        this.player.hp += this.player.healAmount;
        if (this.player.hp > this.player.maxHp) this.player.hp = this.player.maxHp;
        EffectsManager.showEffect(this.gameContainer, this.player.x, this.player.y, `+${this.player.healAmount}`, "heal");
      }
    }
    // ã‚²ãƒ¼ãƒ é–‹å§‹
    new Game();
  </script>
</body>
</html>
